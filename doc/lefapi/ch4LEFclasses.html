<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN" "http://www.w3.org/MarkUp/Wilbur/HTML32.dtd">
<html xmlns="http://www.w3.org/MarkUp/Wilbur/HTML32.dtd">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>LEF 5.8 C/C++ Programming Interface -- 4</title>
<META NAME="Approver" CONTENT="Technical Publications">
<META NAME="Author" CONTENT="Technical Publications">
<META NAME="CreateDate" CONTENT="2017-07-10">
<META NAME="CreateTime" CONTENT="1499670269">
<META NAME="DataType" CONTENT="Manuals">
<META NAME="Description" CONTENT="Describes the C/C++ programming interface used to read and write Library Exchange Format (LEF) files.">
<META NAME="DocTitle" CONTENT="LEF 5.8 C/C++ Programming Interface">
<META NAME="DocType" CONTENT="Reference">
<META NAME="EdmsRelease" CONTENT="FM-Wiki-1.0_P005">
<META NAME="FileTitle" CONTENT="4">
<META NAME="Keywords" CONTENT="">
<META NAME="FileType" CONTENT="Chapter">
<META NAME="Keyword" CONTENT="lefapi">
<META NAME="Language" CONTENT="English">
<META NAME="ModifiedDate" CONTENT="2017-07-10">
<META NAME="ModifiedTime" CONTENT="1499670269">
<META NAME="NextFile" CONTENT="ch5LEFwritercallback.html">
<META NAME="PageCount" CONTENT="52">
<META NAME="Platform" CONTENT="ALL">
<META NAME="PrevFile" CONTENT="ch3LEFcallback.html">
<META NAME="Product" CONTENT="Innovus, Languages">
<META NAME="ProductFamily" CONTENT="Digital Implementation, Cadence Shared Tools">
<META NAME="ProductVersion" CONTENT="5.8">
<META NAME="Syntax" CONTENT="    // Check if PROPERTY is defined in the macro    propNum = macroInfo->numProperties();    if (propNum > 0) {        printf(&quot;  PROPERTY &quot;);        for (i = 0; i < propNum; i++) {            // value can either be a string or number            if (macroInfo->propValue(i)) {                printf(&quot;%s %s &quot;, macroInfo->propName(i),                       macroInfo->propValue(i));            }            else                printf(&quot;%s %g &quot;, macroInfo->propName(i),    macroInfo->propNum(i));        }        printf(&quot;\n&quot;);    }    return 0;},    // Check if SITE pattern is defined in the macro    if (macroInfo->hasSitePattern()) {        for (i = 0; i < macroInfo->numSitePattern(); i++ ) {            pattern = macroInfo->sitePattern(i);            printf(&quot;  SITE %s %g %g %d DO %g BY %g STEP %g %g\n&quot;,                   pattern->name(), pattern->x(), pattern->y(),                   pattern->orient(), pattern->xStart(),     pattern->yStart(),                   pattern->xStep(), pattern->yStep());        }    },    // Check if the type is correct    if (type != lefrMacroCbkType) {        printf(&quot;Type is not lefrMacroCbkType, terminate parsing.\n&quot;);        return 1;    }    if (macroInfo->hasClass())       printf(&quot;  CLASS %s\n&quot;, macroInfo->macroClass());,    // Check if the type is correct    if (type != lefrPinCbkType) {        printf(&quot;Type is not lefrPinCbkType, terminate parsing.\n&quot;);        return 1;    },    // Check if the type is correct    if (type != lefrPropBeginCbkType) {        printf(&quot;Type is not lefrPropBeginCbkType, terminate parsing.\n&quot;);        return 1;    },    // Check if the type is correct    if (type != lefrPropCbkType) {        printf(&quot;Type is not lefrPropCbkType, terminate parsing.\n&quot;);        return 1;    },    // Check if the type is correct    if (type != lefrPropEndCbkType) {        printf(&quot;Type is not lefrPropEndCbkType, terminate parsing.\n&quot;);        return 1;}    printf(&quot;END PROPERTYDEFINITIONS\n&quot;);    return 0;},    // Check if the type is correct    if (type != lefrSiteCbkType) {        printf(&quot;Type is not lefrSiteCbkType, terminate parsing.\n&quot;);        return 1;    },    // Check if the type is correct    if (type != lefrSpacingCbkType) {        printf(&quot;Type is not lefrSpacingCbkType, terminate parsing.\n&quot;);        return 1;    },    // Check if the type is correct    if (type != lefrUnitsCbkType) {        printf(&quot;Type is not lefrUnitsCbkType, terminate parsing.\n&quot;);        return 1;},    // Check the object type of the property definition    if (strcmp(propInfo->propType(), &quot;library&quot;) == 0)        printf(&quot;LIBRARY %s &quot;, propInfo->propName());    else if (strcmp(propInfo->propType(), &quot;pin&quot;) == 0)        printf(&quot;PIN %s &quot;, propInfo->propName());    else if (strcmp(propInfo->propType(), &quot;macro&quot;) == 0)        printf(&quot;MACRO %s &quot;, propInfo->propName());    else if (strcmp(propInfo->propType(), &quot;via&quot;) == 0)        printf(&quot;VIA %s &quot;, propInfo->propName());    else if (strcmp(propInfo->propType(), &quot;viarule&quot;) == 0)        printf(&quot;VIARULE %s &quot;, propInfo->propName());    else if (strcmp(propInfo->propType(), &quot;layer&quot;) == 0)        printf(&quot;LAYER %s &quot;, propInfo->propName());    else if (strcmp(propInfo->propType(), &quot;nondefaultrule&quot;) == 0        printf(&quot;NONDEFAULTRULE %s &quot;, propInfo->propName());,    // Check the property type    if (propInfo->dataType() == ÕIÕ)        printf(&quot;INTEGER &quot;);    if (propInfo->dataType() == ÕRÕ)        printf(&quot;REAL &quot;);    if (propInfo->dataType() == ÕSÕ)        printf(&quot;STRING &quot;);    if (propInfo->dataType() == ÕQÕ)        printf(&quot;STRING &quot;);    if (propInfo->hasRange()) {        printf(&quot;RANGE %g %g &quot;, propInfo->left(), propInfo->right());    }    if (propInfo->hasNumber())        printf(&quot;%g &quot;, propInfo->number());    if (propInfo->hasString())        printf(&quot;'%s' &quot;, propInfo->string());    printf(&quot;\n&quot;);    return 0;},    // Expect a non null char* macroName    if (!macroName || !*macroName) {        printf(&quot;Macro name is null, terminate parsing.\n&quot;);        return 1;    },    // Write out the macro name    printf(&quot;Macro name is %s\n&quot;, macroName);    return 0;},     // Check if the type is correct    if (type != lefrNonDefaultCbkType) {        printf(&quot;Type is not lefrNonDefaultCbkType, terminate parsing.\n&quot;);        return 1; }// Print out nondefaultrule data    printf(&quot;NONDEFAULTRULE %s\n&quot;, def->name());    for (i = 0; i < def->numLayers(); i++) {        printf(&quot;  LAYER %s\n&quot;, def->layerName(i));        if (def->hasLayerWidth(i))            printf(&quot;    WIDTH %g\n&quot;, def->layerWidth(i));        if (def->hasLayerSpacing(i))            printf(&quot;    SPACING %g\n&quot;, def->layerSpacing(i));},     // Incorrect type was passed in, expecting the type// lefiMacroBeginCbkType    if (type != lefiMacroBeginCbkType) {        printf(&quot;Type is not lefiMacroBeginCbkType, terminate parsing.\n&quot;);        return 1;    },     // handle via in nondefaultrule    for (i = 0; i < def->numVias(); i++) {        via = def->viaRule(i);    // handle spacing in nondefaultrule    for (i = 0; i < def->numSpacingRules(); i++) {        spacing = def->spacingRule(i);}  return 0;},         if (siteInfo->hasSize())        printf(&quot;  SIZE %g BY %g\n&quot;, siteInfo->sizeX(), siteInfo->sizeY());    printf(&quot;END %s\n&quot;, siteInfo->name());    return 0;},         printf(&quot;OBS\n&quot;);    geometry = obs->geometries();    numItems = geometry->numItems();    for (i = 0; i < numItems; i++) {        switch (geometry->itemType(i)) {            case lefiGeomClassE:                 printf(&quot;   CLASS %s\n&quot;, geometry->getClass(i));                 break;            case lefiGeomLayerE:                 printf(&quot;   LAYER %s\n&quot;, geometry->getLayer(i));                 break;            case lefiGeomWidthE:                 printf(&quot;   WIDTH %g\n&quot;, geometry->getWidth(i))                 break;            case lefiGeomPathE:                 path = geometry->getPath(i);                 printf(&quot;   PATH&quot;);                 for (j = 0; j < path->numPoints; j++)                     printf(&quot; ( %g %g )&quot;, path->x[j], path->y[j]);                 printf(&quot;\n&quot;);                 break;            case lefiGeomPathIterE:                 pathIter = geometry->getPathIter(i);                 printf(&quot;   PATH ITERATED&quot;);                 for (j = 0; j < pathIter->numPoints; j++)                     printf(&quot; ( %g %g )&quot;, pathIter->x[j],     pathIter ->y[j]);                 printf(&quot;\n&quot;);                 printf(&quot;   DO %g BY %g STEP %g %g\n&quot;, pathIter->xStart, pathIter->yStart, pathIter->xStep, pathIter->yStep);                 break;            case lefiGeomRectE:                 rect = geometry->getRect(i);                 printf(&quot;   RECT ( %g %g ) ( %g %g )\n&quot;, rect->xl,                        rect->yl, rect->xh, rect->yh);                 break;            case lefiGeomRectIterE:                 rectIter = geometry->getRectIter(i);                 printf(&quot;   RECT ITERATE ( %g %g ) ( %g %g )\n&quot;, rectIter->xl, rectIter->yl, rectIter->xh, rectIter->yh);                 printf(&quot;   DO %g BY %g STEP %g %g\n&quot;, rectIter->xStart, rectIter->yStart, rectIter->xStep, rectIter->yStep);                 break;            case lefiGeomPolygonE:                 polygon = geometry->getPolygon(i);                 printf(&quot;   POLYGON&quot;);                 for (j = 0; j < polygon->numPoints; j++)                     printf(&quot; ( %g %g )&quot;, polygon->x[j], polygon->y[j]);                 printf(&quot;\n&quot;);                 break;            case lefiGeomPolygonIterE:                 polygonIter = geometry->getPolygonIter(i);                 printf(&quot;   POLYGON ITERATE&quot;);                 for (j = 0; j < polygonIter->numPoints; j++)                    printf(&quot; ( %g %g )&quot;, polygonIter->x[j],polygonIter->y[j]);                 printf(&quot;\n&quot;);                 printf(&quot;   DO %g BY %g STEP %g %g\n&quot;, polygonIter->xStart, polygonIter->yStart, polygonIter->xStep, polygonIter->yStep);                 break;            case lefiGeomViaE:                 via = geometry->getVia(i);                 printf(&quot;   VIA ( %g %g ) %s\n&quot;, via->x, via->y, via->name);                 break;            case lefiGeomViaIterE:                 viaIter = geometry->getViaIter(i);                 printf(&quot;   VIA ITERATE ( %g %g ) %s\n&quot;, viaIter->x, viaIter->y, viaIter->name);                 printf(&quot;   DO %g BY %g STEP %g %g\n&quot;, viaIter->xStart, viaIter->yStart, viaIter->xStep, viaIter->yStep);                 break;        }    }    return 0; },         printf(&quot;SAMENET %s %s %g &quot;, spacingInfo->name1(), spacingInfo->name2(), spacingInfo->distance());    if (spacingInfo->hasStack())        printf(&quot;STACK &quot;);    printf(&quot;\n&quot;);    return 0; },         printf(&quot;SITE %s\n&quot;, siteInfo->name());    if (siteInfo->hasClass())        printf(&quot;  CLASS %s\n&quot;, siteInfo->siteClass());    if (siteInfo->hasXSymmetry()) {        printf(&quot;  SYMMETRY X &quot;);        hasPrtSym = 1; // set the flag that the keyword SYMMETRY has written    }    if (siteInfo->hasYSymmetry()) {        if (hasPrtSym)            printf(&quot;Y &quot;);        else {         // keyword SYMMETRY has not been written yet            printf(&quot;  SYMMETRY Y &quot;);            hasPrtSym = 1;        }    }    if (siteInfo->has90Symmetry()) {        if (hasPrtSym)            printf(&quot;R90 &quot;);        else {            printf(&quot;  SYMMETRY R90 &quot;);            hasPrtSym = 1;        }    }    if (hasPrtSym)        printf(&quot;\n&quot;);,    if (macroInfo->hasXSymmetry()) {       printf(&quot;  SYMMETRY X &quot;);       hasPrtSym = 1;    }    if (macroInfo->hasYSymmetry()) {   // print X Y & R90 in one line       if (!hasPrtSym) {               // the line has not started yet          printf(&quot;  SYMMETRY Y &quot;);          hasPrtSym = 1;       }       else                            // the line has already started          printf(&quot;Y &quot;);    }    if (macroInfo->has90Symmetry()) {       if (!hasPrtSym) {               // the line has not started yet          printf(&quot;  SYMMETRY R90 &quot;);          hasPrtSym = 1;       }       else                            // the line has already started          printf(&quot;R90 &quot;);    }    if (hasPrtSym) {        printf (&quot;\n&quot;);        hasPrtSym = 0;    },    if (pin->hasAntennaSize()) {        for (i = 0; i < pin->numAntennaSize(); i++) {            printf(&quot;  ANTENNASIZE %g &quot;, pin->antennaSize(i));           if (pin->antennaSizeLayer(i))               printf(&quot;LAYER %s &quot;, pin->antennaSizeLayer(i));           printf(&quot;\n&quot;);        }    },    if (pin->hasLEQ())        printf(&quot;  LEQ %s\n&quot;, pin->LEQ());,    int i, j;    // Check if the type is correct    if (type != lefrViaCbkType) {        printf(&quot;Type is not lefrViaCbkType, terminate parsing.\n&quot;);        return 1;}    printf(&quot;VIA %s &quot;, viaInfo->lefiVia::name());    if (viaInfo->hasDefault())        printf(&quot;DEFAULT\n&quot;);    else        printf(&quot;\n&quot;);    if (viaInfo->hasTopOfStack())        printf(&quot;  TOPOFSTACKONLY\n&quot;);    if (viaInfo->hasForeign()) {        printf(&quot;  FOREIGN %s &quot;, viaInfo->foreign());        if (viaInfo->hasForeignPnt()) {            printf(&quot;( %g %g ) &quot;, viaInfo->foreignX(), viaInfo->foreignY());           if (viaInfo->hasForeignOrient())               printf(&quot;%s &quot;, orientStr(viaInfo->foreignOrient()));        }        printf(&quot;\n&quot;);    }    if (viaInfo->hasProperties()) {        printf(&quot;  PROPERTY &quot;);        for (i = 0; i < viaInfo->numProperties(); i++) {            printf(&quot;%s &quot;, viaInfo->propName(i));            if (viaInfo->propIsNumber(i))                printf(&quot;%g &quot;, viaInfo->propNumber(i));            if (viaInfo->propIsString(i))                printf(&quot;%s &quot;, viaInfo->propValue(i));        }        printf(&quot;\n&quot;);    }    if (viaInfo->hasResistance())        printf(&quot;  RESISTANCE %g\n&quot;, viaInfo->resistance());    if (viaInfo->numLayers() > 0) {        for (i = 0; i < viaInfo->numLayers(); i++) {            printf(&quot;  LAYER %s\n&quot;, viaInfo->layerName(i));            for (j = 0; j < viaInfo->numRects(i); j++)                printf(&quot;    RECT ( %g %g ) ( %g %g )\n&quot;,                       viaInfo->xl(i, j), viaInfo->yl(i, j),                       viaInfo->xh(i, j), viaInfo->yh(i, j));         }     }     printf(&quot;END %s\n&quot;, viaInfo->name());     return 0;},    numPorts = pin->numPorts();    for (i = 0; i < numPorts; i++) {        printf(&quot;  PORT\n&quot;);        geometry = pin->port(i);        // A complete example can be found on page 76.        numItems = geometry->numItems();        for (j = 0; j < numItems; j++) {            switch (geometry->itemType(j)) {                case lefiGeomClassE:                     printf(&quot;   CLASS %s\n&quot;, geometry->getClass(j));                     break;                case lefiGeomLayerE:                     printf(&quot;   LAYER %s\n&quot;, geometry->getLayer(j));                     break;                case lefiGeomWidthE:                     printf(&quot;   WIDTH %g\n&quot;, geometry->getWidth(j));                     break;                case lefiGeomPathE:                     ...                     break;                case lefiGeomPathIterE:                     ...                     break;                case lefiGeomRectE:                     rect = geometry->getRect(j);                     printf(&quot;   RECT ( %g %g ) ( %g %g )\n&quot;, rect->xl,                            rect->yl, rect->xh, rect->yh);                     break;                case lefiGeomRectIterE:                     ...                     break;                case lefiGeomPolygonE:                     ...                     break;                case lefiGeomPolygonIterE:                     ...                     break;                case lefiGeomViaE:                     ...                     break;                case lefiGeomViaIterE:                     ...                     break;            }        }    }    return 0; },    printf(&quot;PIN %s\n&quot;, pin->name());    if (pin->hasForeign()) {        if (pin->hasForeignOrient())            printf(&quot;  FOREIGN %s STRUCTURE ( %g %g ) %d\n&quot;, pin->foreignName(), pin->foreignX(), pin->foreignY(), pin->foreignOrient());        else if (pin->hasForeignPoint())            printf(&quot;  FOREIGN %s STRUCTURE ( %g %g )\n&quot;, pin->foreignName(), pin->foreignX(), pin->foreignY());        else            printf(&quot;  FOREIGN %s\n&quot;, pin->foreignName());    },    printf(&quot;PROPERTYDEFINITIONS\n&quot;);    return 0;},    printf(&quot;UNITS\n&quot;);    if (unitInfo->hasDatabase())        printf(&quot;  DATABASE %s %g\n&quot;, unitInfo->databaseName(),                unitInfo->databaseNumber());    if (unitInfo->hasCapacitance())        printf(&quot;  CAPACITANCE PICOFARADS %g\n&quot;,                unitInfo->capacitance());    if (unitInfo->hasResistance())        printf(&quot;  RESISTANCE OHMS %g\n&quot;, unitInfo->resistance());    if (unitInfo->hasPower())        printf(&quot;  POWER MILLIWATTS %g\n&quot;, unitInfo->power());    if (unitInfo->hasCurrent())        printf(&quot;  CURRENT MILLIAMPS %g\n&quot;, unitInfo->current());    if (unitInfo->hasVoltage())        printf(&quot;  VOLTAGE VOLTS %g\n&quot;, unitInfo->voltage());    if (unitInfo->hasFrequency())        printf(&quot;  FREQUENCY MEGAHERTZ %g\n&quot;, unitInfo->frequency());    printf(&quot;END UNITS\n&quot;);    return 0;};,     char*  name() const;int isHorizontal() const;int isVertical() const;double enclosureOverhang1() const;double enclosureOverhang2() const;double widthMin() const;double widthMax() const;double overhang() const;double metalOverhang() const;double resistance() const;double spacingStepX() const;double spacingStepY() const;double xl() const; double yl() const;double xh() const;double yh() const; };,     const char* databaseName();double databaseNumber();double capacitance();double resistance();double time();double power();double current();double voltage();double frequency();};,     const char* name() const;const char* macroClass() const;const char* generator() const;const char* EEQ() const;const char* LEQ() const;const char* source() const;const char* clockType() const;double originX() const;double originY() const;double power() const;void generate(char** name1, char** name2) const;lefiSitePattern* sitePattern(int index) const;const char* siteName() const;double sizeX() const;double sizeY() const;int numForeigns() const;int foreignOrient(int index = 0) const;   //optional - for information, see       //Orientation Codes on page 21 const char* foreignOrientStr(int index = 0) const;double foreignX(int index = 0) const;double foreignY(int index = 0) const;const char* foreignName(int index = 0) const; };,     int numLayers() const;char* layerName(int layerNum) const;int numRects(int layerNum) const;double xl(int layerNum, int rectNum) const;double yl(int layerNum, int rectNum) const;double xh(int layerNum, int rectNum) const;double yh(int layerNum, int rectNum) const;int numPolygons(int layerNum) const;struct lefiGeomPolygon getPolygon(int layerNum, int polyNum) const;char* name() const ;double resistance() const ;,     int numLayers() const;const char* layerName(int index) const;int hasLayerWidth(int index) const;double layerWidth(int index) const;int hasLayerSpacing(int index) const;double layerSpacing(int index) const;int hasLayerWireExtension(int index) const;double layerWireExtension(int index) const;int hasLayerDiagWidth(int index) const;double layerDiagWidth(int index) const;int numVias() const;lefiVia* viaRule(int index) const;,     int numLayers() const;lefiViaRuleLayer* layer(int index);,     int numProperties() const ;char* propName(int index) const;char* propValue(int index) const;double propNumber(int index) const;char propType(int index) const:int propIsNumber(int index) const;int propIsString(int index) const;char* foreign() const;double foreignX() const;double foreignY() const;int foreignOrient() const;char* foreignOrientStr() const; int hasViaRule() const;const char* viaRuleName() const;double xCutSize() const;double yCutSize() const;const char* botMetalLayer() const;const char* cutLayer() const;const char* topMetalLayer() const;double xCutSpacing() const;double yCutSpacing() const;double xBotEnc() const;double yBotEnc() const;double xTopEnc() const;double yTopEnc() const;int hasRowCol() const;int numCutRows() const;int numCutCols() const;int hasOrigin() const;double xOffset() const;double yOffset() const;int hasOffset() const;double xBotOffset() const;double yBotOffset() const;double xTopOffset() const;double yTopOffset() const;int hasCutPattern() const;const char* cutPattern() const;      double xl,      double yl,     double xh,     double yh);     lefiGeometries* geom); int rectColorMask(int layerNum,      int rectNum); int polyColorMask(int layerNum,      int rectNum); };,     int numProps() const;const char* propName(int index) const;const char* propValue(int index) const;double propNumber(int index) const;const char propType(int index) const;int propIsNumber(int index) const;int propISString(int index) const; };,     int numSitePattern() const;int numProperties() const;const char* propName(int index) const;const char* propValue(int index) const;double propNum(int index) const;const char propType(int index) const;int propIsNumber(int index) const;int propIsString(int index) const;,     int numSpacingRules() const;lefiSpacing* spacingRule(int index) const;int numUseVia() const;const char* viaName(int index) const;int numUseViaRule() const;const char* viaRuleName(int index) const;int numMinCuts() const;const char* cutLayerName(int index) const;int numCuts(int index) const; };,     int numVias() const;char* viaName(int index) const; ,char * lefiSite_siteName  ( const lefiSite * this, int index );,char * lefiSite_siteOrientStr  ( const lefiSite * this, int index );,class lefiAntennaModel {int hasAntennaAreaRatio() const;int hasAntennaDiffAreaRatio() const; int hasAntennaDiffAreaRatioPWL() const;int hasAntennaCumAreaRatio() const;int hasAntennaCumDiffAreaRatio() constint hasAntennaCumDiffAreaRatioPWL() const;int hasAntennaAreaFactor() const;int hasAntennaAreaFactorDUO() const;int hasAntennaSideAreaRatio() const;int hasAntennaDiffSideAreaRatio() const;int hasAntennaDiffSideAreaRatioPWL() const;int hasAntennaCumSideAreaRatio() const;int hasAntennaCumDiffSideAreaRatio() const;int hasAntennaCumDiffSideAreaRatioPWL() const;int hasAntennaSideAreaFactor() const;int hasAntennaSideAreaFactorDUO() const;int hasAntennaCumRoutingPlusCut() const;int hasAntennaGatePlusDiff() const;int hasAntennaAreaMinusDiff() const;int hasAntennaAreaDiffReducePWL() const; char* antennaOxide() const;double antennaAreaRatio() const;double antennaDiffAreaRatio() const;lefiAntennaPWL* antennaDiffAreaRatioPWL() const;double antennaCumAreaRatio() const;double antennaCumDiffAreaRatio() const;lefiAntennaPWL* antennaCumDiffAreaRatioPWL() const;double antennaAreaFactor() const;double antennaSideAreaRatio() const;double antennaDiffSideAreaRatio() const;lefiAntennaPWL* antennaDiffSideAreaRatioPWL() const;double antennaCumSideAreaRatio() const;double antennaCumDiffSideAreaRatio() const;lefiAntennaPWL* antennaCumDiffSideAreaRatioPWL() const;double antennaSideAreaFactor() const; double antennaGatePlusDiff() const;double antennaAreaMinusDiff() const;lefiAntennaPWL* antennaAreaDiffReducePWL() const; };,class lefiAntennaModel {int hasAntennaGateArea() const;int hasAntennaMaxAreaCar() consint hasAntennaMaxSideAreaCar() const;int hasAntennaMaxCutCar() const;char* antennaOxide() const;int numantennaGateArea() const;double antennaGateArea(int index) const;const char* antennaGateAreaLayer(int index) const;int numAntennaMaxAreaCar() const;double antennaMaxAreaCar(int index) const;const char* antennaMaxAreaCarLayer(int index) const;int numAntennaMaxSideAreaCar() conts;double antennaMaxSideAreaCar(int index) const;const char* antennaMaxSideAreaCarLayer(int index) const;int numAntennaMaxCutCar() const;double antennaMaxCutCar(int index) const;const char* antennaMaxCutCarLayer(int index) const; };,class lefiAntennaPWL {int numPWL() const;double PWLdiffusion(int index):double PWLratio(int index); };,class lefiDensity {int numLayer() const;char* layerName(int index) const;int numRects(int index) const;struct lefiGeomRect getRect(int index, int rectIndex) const;double densityValue(int index, int rectIndex) const; };,class lefiGeometries {int    numItems() const;enum   lefiGeomEnum itemType(int index) const;struct lefiGeomRect* getRect(int index) const;struct lefiGeomRectIter* getRectIter(int index) const;struct lefiGeomPath* getPath(int index) const;struct lefiGeomPathIter* getPathIter(int index) const;int    hasLayerExceptPgNet(int index) const;char*  getLayer(int index) const;double getLayerMinSpacing(int index) const;double getLayerRuleWidth(int index) const;double getWidth(int index) const;struct lefiGeomPolygon* getPolygon(int index) const;struct lefiGeomPolygonIter* getPolygonIter(int index) const;char*  getClass(int index) const;struct lefiGeomVia* getVia(int index) const;struct lefiGeomViaIter* getViaIter(int index) const;int colorMask;};,class lefiInfluence {int numInfluenceEntry() const;double width(int index) const;double distance(int index) const;double spacing(int index) const; };,class lefiLayer {int hasType() const;int hasPitch() const;                                   // Routingint hasXYPitch() const;int hasOffset() const;                                  // Routing int hasXYOffset() const;int hasWidth() const;                                   // Routing int hasArea() const;int hasDiagPitch() const;int hasXYDiagPitch() const;int hasDiagWidth() const;int hasDiagSpacing() const;int hasSpacingNumber() const;         int hasSpacingName(int index) const;int hasSpacingLayerStack(int index) const;int hasSpacingAdjacent(int index) const;int hasSpacingCenterToCenter(int index) const;int hasSpacingRange(int index) const;                   // Routing int hasSpacingRangeUseLengthThreshold(int index) const;int hasSpacingRangeInfluence(int index) const;int hasSpacingRangeInfluenceRange(int index) const;int hasSpacingRangeRange(int index) const;int hasSpacingLengthThreshold(int index) const;         // Routingint hasSpacingLengthThresholdRange(int index) const;    // Routingint hasSpacingParallelOverlap(int index) const;int hasSpacingArea(int index) const;int hasSpacingEndOfLine(int index) const;int hasSpacingParellelEdge(int index) const;int hasSpacingTwoEdges(int index) const;int hasSpacingAdjacentExcept(int index) const;int hasSpacingSamenet(int index) const;int hasSpacingSamenetPGonly(int index) const;int hasSpacingNotchLength(int index) const;int hasSpacingEndOfNotchWidth(int index) const;int hasDirection() const;                               // Routing int hasResistance() const;                              // Routing int hasResistanceArray() const;int hasCapacitance() const;                             // Routing int hasCapacitanceArray() const;int hasHeight() const;                                // Routing int hasThickness() const;                             // Routing int hasWireExtension() const;                         // Routing int hasShrinkage() const;                             // Routing int hasCapMultiplier() const;                         // Routing int hasEdgeCap() const;                               // Routing int hasAntennaLength() const;                         // Routing int hasAntennaArea() const;                           // Routing int hasCurrentDensityPoint() const; int hasCurrentDensityArray() const;int hasAccurrentDensity() const; int hasDccurrentDensity() const; int numProps() const;const char* propName(int index) const;const char* propValue(int index) const;double propNumber(int index) const;const char propType(int index) const;int propIsNumber(int index) const;int propIsString(int index) const;int numSpacing() const;                               // Cut and Routingchar* name() const;const char* type() const;double pitch() const;                                 // Routing double pitchX() const;double pitchY() const;double offset() const;                                // Routing double offsetX() const;double offsetY() cont;double width() const;                   double area() const;double diagPitch() const;double diagPitchX() const;double diagPitchY() const;double diagWidth() const;double diagSpacing() const;double spacing(int index) const;       char*  spacingName(int index) const;                  // Cutint spacingAdjacentCuts(int index) const;             // Cutdouble spacingAdjacentWithin(int index) const;        // Cutdouble spacingArea(int index) const;                  // Cutdouble spacingRangeMin(int index) const;  double spacingRangeMax(int index) const;  double spacingRangeInfluence(int index) const;double spacingRangeInfluenceMin(int index) const;double spacingRangeInfluenceMax(int index) const;double spacingRangeRangeMin(int index) const;double spacingRangeRangeMax(int index) const;double spacingLengthThreshold(int index) const;double spacingLengthThresholdRangeMin(int index) const;double spacingLengthThresholdRangeMax(int index) const;double spacingEolWidth(int index) const;double spacingEolWithin(int index) const;double spacingParSpace(int index) const;double spacingParWithin(int index) const;double spacingNotchLength(int index) const;double spacingEndOfNotchWidth(int index) const;double spacingEndOfNotchSpacing(int index) const;double spacingEndOfNotchLength(int index) const;int numMinimumcut() const;int minimumcut(int index) const;double minimumcutWidth(int index) const;int hasMinimumcutWithin(int index) const;double minimumcutWithin(int index) const;int hasMinimumcutConnection(int index) const;      // FROMABOVE | FROMBELOWconst char* minimumcutConnection(int index) const; // FROMABOVE | FROMBELOWint hasMinimumcutNumCuts(int index) const;double minimumcutLength(int index) const;double minimumcutDistance(int index) const;const char* direction() const;                        // Routing double resistance() const;                            // Routing double capacitance() const;                           // Routing double height() const;                                // Routing double wireExtension() const;                         // Routing double thickness() const;                             // Routing double shrinkage() const;                             // Routing double capMultiplier() const;                         // Routing double edgeCap() const;                               // Routing double antennaLength() const;                         // Routing double antennaArea() const;                           // Routing double currentDensityPoint() const;     void currentDensityArray(int* numPoints, double** widths,     double** current) const;  void capacitanceArray(int* numPoints, double** widths,     double** resValues) const;  void resistanceArray(int* numPoints, double** widths,     double** capValues) const;                      // Routing int numAccurrentDensity() const;lefiLayerDensity* accurrent(int index) const;int numDccurrentDensity() const;lefiLayerDensity* dccurrent(int index) const;int numAntennaModel() const;lefiAntennaModel* antennaModel(int index) const;int hasSlotWireWidth() const;int hasSlotWireLength() const;int hasSlotWidth() const;int hasSlotLength() const;int hasMaxAdjacentSlotSpacing() const;int hasMaxCoaxialSlotSpacing() const;int hasMaxEdgeSlotSpacing() const;int hasSplitWireLength() const;int hasMinimumDensity() const;int hasMaximumDensity() const;int hasDensityCheckWindow() const;int hasDensityCheckStep() const;int hasFillActiveSpacing() const;int hasMaxwidth() const;int hasMinwidth() const; int hasMinstep() const;int hasProtrusion() const;double slotWireWidth() const;double slotWireLength() const;double slotWidth() const;double slotLength() const;double maxAdjecentSlotSpacing() const;double maxCoaxialSlotSpacing() const;double maxEdgeSlotSpacing() const;double splitWireLength() const;double minimumDensity() constdouble maximumDensity() const;double densityCheckWindowLength() const;double densityCheckWindowWidth() const;double densityCheckStep() const;double fillActiveSpacing() const;double maxwidth() const;double minwidth() const;double minstep() const;double protrusionWidth1() const;double protrusionLength() const;double protrusionWidth2() const;int numMistep() const;double minstep(int index) const;int hasMinstepType(int index) const;char* minstepType(int index) const;int hasMinstepLengthsum(int index) const;double minstepLengthsum(int index) const;int hasMinstepMaxedges(int index) const;int minstepMaxedges(int index) const;int numMinenclosedarea() const;double minenclosedarea(int index) const;int hasMinenclosedareaWidth(int index) const;double minenclosedareaWidth(int index) const;int numSpacingTable();lefiSpacingTable* spacingTable(int index);int numEnclosure() const;int hasEnclosureRule(int index) const;char* enclosureRule (int index);double enclosureOverhang1(int index) const;double enclosureOverhang2(int index) const;int hasEnclosureWidth(int index) const;double enclosureMinWidth(int index) const;int hasEnclosureExceptExtraCut(int index) const;double enclosureExceptExtraCut(int index) const;int hasEnclosureMinLength(int index) const;double enclosureMinLength(int index) const;int numPreferEnclosure() const;int hasPreferEnclosureRule(int index) const;char* preferEnclosureRule(int index) const;double preferEnclosureOverhang1(int index) const;double preferEnclosureOverhang2(int index) const;int hasPreferEnclosureWidth(int index) const;double preferEnclosureMinWidth(int index) const;int hasResistancePerCut() const;double resistancePerCut() const;int hasMinEdgeLength() const;double minEdgeLength() const;int hasDiagMinEdgeLength() const;double diagMinEdgeLength() const; int hasMinSize() const;int numMinSize() const;double minSizeWidth(int index) const;double minSizeLength(int index)const ; int hasMaxFloatingArea() const;double maxFloatingArea() const;int hasArraySpacing() const;int hasLongArray() const;int hasViaWidth() const;double viaWidth() const;double cutSpacing() const;int numArrayCuts() const;int arrayCuts(int index) const;double arraySpacing(int index) const;int hasSpacingTableOrtho() const;lefiOrthogonal *orthogonal() const; int hasMask() const;         // Check the layer has color mask assigned or not.  int mask() const; };        // Return the color mask number of the layer.,class lefiLayerDensity {  char* type();  int hasOneEntry();  double oneEntry();  int numFrequency();  double frequency(int index);  int numWidths();  double width(int index);  int numTableEntries();  double tableEntry(int index);  int numCutareas();  double cutArea(int index); };,class lefiMacro {int hasClass() const;int hasGenerator() const;int hasGenerate() const;int hasPower() const;int hasOrigin() const;int hasEEQ() const;int hasLEQ() const;int hasSource() const;int hasXSymmetry() const;int hasYSymmetry() const;int has90Symmetry() const;int hasSiteName() const;int hasSitePattern() const;int hasSize() const;int hasForeign() const;int hasForeignOrigin(int index = 0) const;int hasForeignOrient(int index = 0) const;int hasForeignPoint(int index = 0) const;int hasClockType() const;int isBuffer() const;int isInverter() const;,class lefiMacroForeign {public:             lefiMacroForeign(const char *name,                              int        hasPts,                              double     x,                              double     y,                              int        hasOrient,                              int        orient);  const char *cellName() const;  int        cellHasPts() const;  double     px() const;  double     py() const;  int        cellHasOrient() const;  int        cellOrient() const;protected:  const char *cellName_;  int        cellHasPts_;  double     px_;  double     py_;  int        cellHasOrient_;  int        cellOrient_;};,class lefiMacroSite {public:                lefiMacroSite(const char *name, const lefiSitePattern* pattern);  const char            *siteName() const;  const lefiSitePattern *sitePattern() const;protected:  const char            *siteName_;  const lefiSitePattern *sitePattern_;};,class lefiMaxStackVia {int maxStackVia() const;int hasMaxStackViaRange() const;const char* maxStackViaBottomLayer() const;const char* maxStackViaTopLayer() const; },class lefiNonDefault {const char* name() const;int hardSpacing() const;int numProps() const;const char* propName(int index) const;const char* propValue(int index) const;double propNumber(int index) const;const char propType(int index) const; int propIsNumber(int index) const;int propIsString(int index) const;,class lefiObstruction {lefiGeometries* geometries() const;};,class lefiOrthogonal {int  numOrthogonal() const;double cutWithin(int index) const;double orthoSpacing(int index) const; };,class lefiParallel {int numLength() const;int numWidth() const;double length(int iLength) const;double width(int iWidth) const;double widthSpacing(int iWidth, int iWidthSpacing) const; };,class lefiPin {int hasForeign() const;int hasForeignOrient(int index = 0) const;int hasForeignPoint(int index = 0) const;int hasLEQ() const;int hasDirection() const;int hasUse() const;int hasShape() const;int hasMustjoin() const;int hasOutMargin() const;int hasOutResistance() const;int hasInMargin() const;int hasPower() const;int hasLeakage() const;int hasMaxload() const;int hasMaxdelay() const;int hasCapacitance() const;int hasResistance() const;int hasPulldownres() const;int hasTieoffr() const;int hasVHI() const;int hasVLO() const;int hasRiseVoltage() const;int hasFallVoltage() const;int hasRiseThresh() const;int hasFallThresh() const;int hasRiseSatcur() const;int hasFallSatcur() const;int hasCurrentSource() const;int hasTables() const;int hasAntennaSize() const;int hasAntennaMetalArea() const;int hasAntennaMetalLength() const;int hasAntennaPartialMetalArea() const;int hasAntennaPartialMetalSideArea() const;int hasAntennaPartialCutArea() const;int hasAntennaDiffArea() const;int hasAntennaModel() const;int hasTaperRule() const;int hasRiseSlewLimit() const;int hasFallSlewLimit() const;int hasNetExpr() const;int hasSupplySensitivity() const;int hasGroundSensitivity() const;const char* name() const;int numPorts() const;lefiGeometries* port(int index) const;int numForeigns() const;const char* foreignName(int index = 0) const;const char* taperRule() const;int foreignOrient(int index = 0) const;  // optional - for information, see           // Orientation Codes on page 21const char* foreignOrientStr(int index = 0) const;double foreignX(int index = 0) const;double foreignY(int index = 0) const;const char* LEQ() const;const char* direction() const;const char* use() const;const char* shape() const;const char* mustjoin() const;double outMarginHigh() const;double outMarginLow() const;double outResistanceHigh() const;double outResistanceLow() const;double inMarginHigh() const;double inMarginLow() const;double power() const;double leakage() const;double maxload() const;double maxdelay() const;double capacitance() const;double resistance() const;double pulldownres() const;double tieoffr() const;double VHI() const;double VLO() const;double riseVoltage() const;double fallVoltage() const;double riseThresh() const;double fallThresh() const;double riseSatcur() const;double fallSatcur() const;double riseSlewLimit() const;double fallSlewLimit() const;const char* currentSource() const;const char* tableHighName() const;const char* tableLowName() const;int numAntennaSize() const;double antennaSize(int index) const;const char* antennaSizeLayer(int index) const;int numAntennaMetalArea() const;double antennaMetalArea(int index) const;const char* antennaMetalAreaLayer(int index) const;int numAntennaMetalLength() const;double antennaMetalLength(int index) const;const char* antennaMetalLengthLayer(int index) const;int numAntennaPartialMetalArea() const;double antennaPartialMetalArea(int index) const;const char* antennaPartialMetalAreaLayer(int index) const;int numAntennaPartialMetalSideArea() const;double antennaPartialMetalSideArea(int index) const;const char* antennaPartialMetalSideAreaLayer(int index) const;int numAntennaPartialCutArea() const;double antennaPartialCutArea(int index) const;const char* antennaPartialCutAreaLayer(int index) const;int numAntennaDiffArea() const;double antennaDiffArea(int index) const;const char* antennaDiffAreaLayer(int index) const;const char* netExpr() const;const char* supplySensitivity() const;const char* groundSensitivity() const;int numantennaModel() const;lefiPinAntennaModel* antennaModel(int index) const;int numProperties() const;const char* propName(int index) const;const char* propValue(int index) const;double propNum(int index) const;const char propType(int index) const;int propIsNumber(int index) const;int propIsString(int index) const; };,class lefiProp {const char* string() const;const char* propType() const;const char* propName() const;char  dataType() const;int hasNumber() const;int hasRange() const;int hasString() const;int hasNameMapString() const;double number() const;double left() const;double right() const;};,class lefiPropType {const char propType(char* name) const; };,class lefiSite {  const char* name() const;  int hasClass() const;  const char* siteClass() const;  double sizeX() const;  double sizeY() const;  int numSites() const;  char* siteName(int index) const;  int   siteOrient(int index) const;  char* siteOrientStr(int index) const;,class lefiSite {const char* name() const;int hasClass() const;const char* siteClass() const;double sizeX() const;double sizeY() const;int hasSize() const;int hasXSymmetry() const;int hasYSymmetry() const;int has90Symmetry() const;int hasRowPattern() const;int numSites() const;char* siteName(int index) const;int siteOrient(int index) const;char* siteOrientStr(int index) const; };,class lefiSpacing {int hasStack() const;const char* name1() const;const char* name2() const;double distance() const;};,class lefiSpacingTable {int isInfluence() const;lefiInfluence* influence() const;int isParallel() const;lefiParallel* parallel() const; lefiTwoWidths* twoWidths() const; };,class lefiTwoWidths {int numWidth() const;double width(int iWidth) const;int hasWidthPRL(int iWidth) const;double widthPRL(int iWidth) const;int numWidthSpacing(int iWidth) const;double widthSpacing(int iWidth, int iWidthSpacing) const; };,class lefiUnits {int hasDatabase();int hasCapacitance();int hasResistance();int hasTime();int hasPower();int hasCurrent();int hasVoltage();int hasFrequency();,class lefiUseMinSpacing { const char* name() const; int value() const;};,class lefiVia {int hasDefault() const ;int hasGenerated() const;int hasForeign() const ;             // optional - for information, see    // Orientation Codes on page 21 int hasForeignPnt() const ;int hasForeignOrient() const ;int hasProperties() const ;int hasResistance() const ;int hasTopOfStack() const ;,class lefiViaLayer {int numRects();char* name();double xl(int index);double yl(int index);double xh(int index);double yh(int index);int numPolygons();struct lefiGeomPolygon* getPolygon(int index) const;      double xl,     double yl     double xh     double yn);     lefiGeometries* geom);int rectColorMask(int index); int polyColorMask(int index); };,class lefiViaRule {int hasGenerate() const;int hasDefault() const;char* name() const;,class lefiViaRuleLayer {int hasDirection() const;int hasEnclosure() const;int hasWidth() const;int hasResistance() const;int hasOverhang() const;int hasMetalOverhang() const;int hasSpacing() const;int hasRect() const;,const char * lefiSite_name  ( const lefiSite * this );,const char * lefiSite_siteClass  ( const lefiSite * this );,double lefiSite_sizeX  ( const lefiSite * this );,double lefiSite_sizeY  ( const lefiSite * this );,enum lefiGeomEnum {lefiGeomunknown = 0,lefiGeomLayerE,lefiGeomLayerMinSpacingE,lefiGeomLayerRuleWidthE,lefiGeomWidthE,lefiGeomPathE,lefiGeomPathIterE,lefiGeomRectE,lefiGeomRectIterE,lefiGeomPolygonE,lefiGeomPolygonIterE,lefiGeomViaE,lefiGeomViaIterE,lefiGeomClassE,lefiGeomEnd };,int lefiSite_hasClass  ( const lefiSite * this );,int lefiSite_numSites  ( const lefiSite * this );,int lefiSite_siteOrient  ( const lefiSite * this, int index );,int macroBeginCB (lefrCallbackType_e type,                  const char *macroName,                  lefiUserData userData) {,int macroCB (lefrCallbackType_e type,             lefiMacro *macroInfo,             lefiUserData userData) {    int              propNum, i, hasPrtSym = 0;    lefiSitePattern* pattern;,int macroObsCB (lefrCallbackType_e type,lefiObstruction* obsInfo,lefiUserData userData) {lefiGeometries*       geometry;int                   numItems;int                   i, j;lefiGeomPath*         path;lefiGeomPathIter*     pathIter;lefiGeomRect*         rect;lefiGeomRectIter*     rectIter;lefiGeomPolygon*      polygon;lefiGeomPolygonIter*  polygonIter;lefiGeomVia*          via;lefiGeomViaIter*      viaIter;// Check if the type is correct    if (type != lefrObstructionCbkType) {        printf(&quot;Type is not lefrObstructionCbkType,  terminate parsing.\n&quot;);        return 1;},int macroPinCB (lefrCallbackType_e type,                lefiPin* pinInfo,                lefiUserData userData) {    lefiGeometries*       geometry;    int                   numPorts;    int                   numItems;    int                   i, j;    lefiGeomPath*         path;    lefiGeomPathIter*     pathIter;    lefiGeomRect*         rect;    lefiGeomRectIter*     rectIter;    lefiGeomPolygon*      polygon;    lefiGeomPolygonIter*  polygonIter;    lefiGeomVia*          via;    lefiGeomViaIter*      viaIter;,int nonDefaultCB (lefrCallbackType_e type,                  lefiNonDefault* nonDefInfo,                  lefiUserData userData) {    int          i;    lefiVia*     via;    lefiSpacing* spacing;,int propDefBeginCB (lefrCallbackType_e type,                    void* dummy,                    lefiUserData userData) {,int propDefCB (lefrCallbackType_e type,               lefiProp* propInfo,               lefiUserData userData) {,int propDefEndCB (lefrCallbackType_e type,                  void* dummy,                  lefiUserData userData) {,int siteCB (lefrCallbackType_e type,            lefiSite* siteInfo,            lefiUserData userData) {    int hasPrtSym = 0;,int spacingCB (lefrCallbackType_e type,               lefiSpacing* spacingInfo,               lefiUserData userData) {,int unitsCB (lefrCallbackType_e type,             lefiUnits* unitInfo,             lefiUserData userData) {,int viaCB (lefrCallbackType_e type,           lefiVia* viaInfo,           lefiUserData userData) {,int viaRuleCB (lefrCallbackType_e type,               lefiViaRule* viaRuleInfo,               lefiUserData userData) {    int               numLayers, numVias, i;    lefiViaRuleLayer* vLayer;    printf(&quot;VIARULE %s&quot;, viaRuleInfo->name());    if (viaRuleInfo->hasGenerate())        printf(&quot; GENERATE\n&quot;);    else        printf(&quot;\n&quot;);    numLayers = viaRuleInfo->numLayers();        // If numLayers == 2, it is VIARULE without GENERATE and has    // via name. If numLayers == 3, it is VIARULE with GENERATE, and   // the 3rd layer is cut.    for (i = 0; i < numLayers; i++) {        vLayer = viaRuleInfo->layer(i);        printf(&quot;  LAYER %s\n&quot;, vLayer->name());        if (vLayer->hasDirection()) {            if (vLayer->isHorizontal())                printf(&quot;    DIRECTION HORIZONTAL\n&quot;);            if (vLayer->isVertical())                printf(&quot;    DIRECTION VERTICAL\n&quot;);        }        if (vLayer->hasWidth())            printf(&quot;    WIDTH %g TO %g\n&quot;, vLayer->widthMin(),                   vLayer->widthMax());        if (vLayer->hasResistance())            printf(&quot;    RESISTANCE %g\n&quot;, vLayer->resistance());        if (vLayer->hasOverhang())            printf(&quot;    OVERHANG %g\n&quot;, vLayer->overhang());        if (vLayer->hasMetalOverhang())            printf(&quot;    METALOVERHANG %g\n&quot;, vLayer->metalOverhang());        if (vLayer->hasSpacing())            printf(&quot;    SPACING %g BY %g\n&quot;, vLayer->spacingStepX(),                   vLayer->spacingStepY());        if (vLayer->hasRect())            printf(&quot;    RECT ( %g %g ) ( %g %g )\n&quot;, vLayer->xl(), vLayer->yl(), vLayer->xh(), vLayer->yh()); }    if (numLayers == 2) {    // should have vianames        numVias = viaRuleInfo->numVias();        if (numVias == 0)            printf(&quot;Should have via names in VIARULE.\n&quot;);        else {            for (i = 0; i < numVias; i++)                printf(&quot;  VIA %s\n&quot;, viaRuleInfo->viaName(i));        }    }    printf(&quot;END %s\n&quot;, viaRuleInfo->name());    return 0;},lefiSitePattern {const char* name() const;int orient() const;const char* orientStr() const;double x() const;double y() const;int hasStepPattern () const;double xStart() const;double yStart() const;double xStep() const;double yStep() const; };,lefiUserData lefrGetUserData(),struct lefiGeomPath {int numPoints;double* x;double* y;int colorMask; };       //specify color mask number for the GeomPath                        //structure.,struct lefiGeomPathIter {int numPoints;double* x;double* y;double  xStart;double  yStart;double  xStep;double  yStep;int colorMask; };    //specify color mask number for the GeomPathIter                     //structure.,struct lefiGeomPolygon {int numPoints;double* x;double* y;int colorMask; };    //specify color mask number for the GeomPolygon                     //structure.,struct lefiGeomPolygonIter {int numPoints;double* x;double* y;double  xStart;double  yStart;double  xStep;double  yStep;int colorMask; };    //specify color mask number for the GeomPolygonIter                     //structure.,struct lefiGeomRect {double xl;double yl;double xh;double yh; int colorMask; };           //specify color mask number for the GeomRect                            //structure.,struct lefiGeomRectIter {double xl;double yl;double xh;double yh;double xStart;double yStart;double xStep;double yStep;int colorMask;};         //specify color mask number for the GeomRectIter                         //structure.,struct lefiGeomVia {char*  name;double x;double y;int topMaskNum;       //define top mask number for the GeomVia structure.int cutMaskNum;       //define cut mask number for the GeomVia structure.int bottomMaskNum;};  //define bottom mask number for the GeomVia structure.,struct lefiGeomViaIter {char*  name;double x;double y;double xStart;double yStart;double xStep;double yStep;int topMaskNum;       //define top mask number for the GeomViaIter structure.int cutMaskNum;       //define cut mask number for the GeomViaIter structure.int bottomMaskNum;};  //define bottom mask number for the GeomViaIter                       //structure.,struct lefiPoints {double x;double y; };,typedef struct lefiPoints lefiNum;,};">
<META NAME="RightsManagement" CONTENT="Copyright 2017 Cadence Design Systems Inc.">
<META NAME="Title" CONTENT="LEF 5.8 C/C++ Programming Interface -- 4">
<META NAME="TopicTags" CONTENT="FALSE">
<META NAME="Version" CONTENT="5.8">
  </head>
  <body style="margin-left: 5%;">
    <a name="pagetop"></a>
    <a name="firstpage"></a>
    <!-- Begin Buttons -->
    <table width="650" cellpadding="0" cellspacing="0" border="0">
      <tr>
        <td height="36" width="650" colspan="10">
          <img src="images/header_doc.gif" width="650" height="34">
        </td>
      </tr>
      <tr>
        <td height="20" width="59">
<a href="javascript:openLibrary()"><img src="../support/nav2_library.gif" border="0" alt="View Library" height="20" width="59"></a>
                </td>
<td height="20" width="73">
<a href="lefapiTOC.html"><img src="../support/nav2_toc.gif" alt="Table of Contents" border="0"></a>
</td>

<td height="20" width="46">
<img src="../support/nav2_index_b.gif" border="0">
</td>
        <td>
          <a href="ch3LEFcallback.html"><img src="images/nav2_previous.gif" alt="Previous" border="0"></a>
        </td>
        <td>
          <a href="ch5LEFwritercallback.html"><img src="images/nav_next.gif" alt="Next" border="0"></a>
        </td>
        <td height="20">
          <a>
<a href="lefapi.pdf"><img src="../support/nav2_print.gif" border="0" alt="Open PDF to print book" height="20" width="114"></a>
          </a>
        </td>
        <td height="20" width="61">
<img src="../support/nav2_black.gif" border="0"  height="20" width="76">
        </td>
        <td height="20" width="76">
<a href="/feedback.htm"><img src="../support/nav2_feedback.gif" border="0" alt="Email Comments" height="20" width="76"></a>
        </td>
        <td height="20" width="43">
<a href="../cdsuser/help.html"><img src="../support/nav2_help.gif" border="0" alt="Help Using Documentation" height="20" width="43"></a>
        </td>
        <td height="20" width="37">
<a href="/exitsearch.htm"><img src="../support/nav2_exit.gif" border="0" alt="Shut Down Cadence Documentation Server" height="20" width="37"></a>
        </td>
      </tr>
    </table>
    <!-- End Buttons -->
    <p>
    <hr>
    <p>
      <h3>
        <center>
          <font >
            <div>LEF 5.8 C&#47;C++ Programming Interface  (Open Licensing Program)</div>
            <font >
              <div></div>
            </font>
          </font>
        </center>
      </h3>
      <br>
    </p>
    <div>
      <h1>4<a name="1008781">&nbsp;</a></h1>
      <h1><a name="1011663">LEF Reader Classes</a></h1>
      <p><a name="1014136">This chapter contains the following sections:</a></p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1039989" title="4" name="1039990"><font color="#0000ff"><u>Introduction</u></font></a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1031286" title="4" name="1039991"><font color="#0000ff"><u>Callback Style Interface</u></font></a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1031187" title="4" name="1039992"><font color="Blue"><u>Retrieving Repeating LEF Data</u></font></a><a href="#1031187" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1031283" title="4" name="1039993"><font color="Blue"><u>Deriving C Syntax from C++ Syntax</u></font></a><a href="#1031283" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1064282" title="4" name="1039994"><font color="Blue"><u>LEF Reader Classes</u></font></a><a href="#1064282" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h2><a name="1039989">Introduction</a></h2>
      <p><a name="1031247">Every statement in the Cadence</a><font color="#000000"><sup>&#174;</sup></font> Library Exchange Format (LEF) file is associated with a LEF reader class. When the LEF reader uses a callback, it passes a pointer to the appropriate class. You can use the member functions in each class to retrieve data defined in the LEF file.</p>
      <p><a name="1031245">For a list of the LEF Reader Classes that correspond to LEF file syntax, see </a><a href="#1064282" title="4"><font color="Blue"><u>"LEF Reader Classes"</u></font></a><a href="#1064282" title="4"></a>.</p>
      <h2><a name="1031286">Callback Style Interface</a></h2>
      <p><a name="1031289">This programming interface uses a callback style interface. You register for the constructs that interest you, and the readers call your callback functions when one of those constructs is read. If you are not interested in a given set of information, you simply do not register the callback; the reader scans the information quickly and proceeds.</a></p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="13.333333333333332">
              <div>&nbsp;</div>
            </td>
            <td width="133.33333333333331">
              <div>
                <nobr>
                  <font size="3"><img src="images/important.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td>
              <font size="3"><a name="1030736">Returned data is not static. If you want to keep the data, you must copy it. </a></font>
            </td>
          </tr>
        </table>
      </div>
      <h2><a name="1031187">Retrieving Repeating LEF Data</a></h2>
      <p><a name="1031239">Many LEF objects contain repeating objects or specifications. The classes that correspond to these LEF objects contain an index and array of elements that let you retrieve the data iteratively. </a></p>
      <p><a name="1031220">You can use a </a><font size="2" face="'Courier New'" color="#000000">for</font> loop from <font size="2" face="'Courier New'" color="#000000">0</font> to the number of items specified in the index. In the loop, retrieve the data from the subsequent arrays. For example:</p>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058306">for (i = 0; i &#60; layer&#45;&#62;lefiLayer::numMinstep(); i++) {</a></font>
      </p>
      <blockquote>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"></font>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058317">   fprintf(fout, &#34;  MINSTEP %g &#34;, layer&#45;&#62;lefiLayer::minstep(i));</a></font>
      </blockquote>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058308">       if (layer&#45;&#62;lefiLayer::hasMinstepType(i))</a></font>
      </p>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058309">          fprintf(fout, &#34;%s &#34;, layer&#45;&#62;lefiLayer::minstepType(i));</a></font>
      </p>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058310">       if (layer&#45;&#62;lefiLayer::hasMinstepLengthsum(i))</a></font>
      </p>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058311">          fprintf(fout, &#34;LENGTHSUM %g &#34;,</a></font>
      </p>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058312">                  layer&#45;&#62;lefiLayer::minstepLengthsum(i));</a></font>
      </p>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058313">       fprintf(fout, &#34;;\n&#34;);</a></font>
      </p>
      <p>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058314">    }</a></font>
      </p>
      <h2><a name="1031283">Deriving C Syntax from C++ Syntax</a></h2>
      <p><a name="1031300">The Cadence application programming interface (API) provides both C and C++ interfaces. The C API is generated from the C++ source, so there is no functional difference. The C API has been created in a pseudo object&#45;oriented style. Examining a simple case should enable you to understand the API organization.</a></p>
      <p><a name="1032142">The following examples show the same statements in C and C++ syntax.</a></p>
      <h3><a name="1031310">C++ Syntax</a></h3>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058322">class lefiSite {<dd>  const char* name() const;<dd>  int hasClass() const;<dd>  const char* siteClass() const;<dd>  double sizeX() const;<dd>  double sizeY() const;<dd>  int numSites() const;<dd>  char* siteName(int index) const;<dd>  int   siteOrient(int index) const;<dd>  char* siteOrientStr(int index) const;</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058339">};</a></font>
      </dl>
      <h3><a name="1036592">C Syntax</a></h3>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058340">const char * lefiSite_name<dd>  ( const lefiSite * this );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058344">int lefiSite_hasClass<dd>  ( const lefiSite * this );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058347">const char * lefiSite_siteClass<dd>  ( const lefiSite * this );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058350">double lefiSite_sizeX<dd>  ( const lefiSite * this );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058352">double lefiSite_sizeY<dd>  ( const lefiSite * this );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058355">int lefiSite_numSites<dd>  ( const lefiSite * this );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058358">char * lefiSite_siteName<dd>  ( const lefiSite * this, int index );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058361">int lefiSite_siteOrient<dd>  ( const lefiSite * this, int index );</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058364">char * lefiSite_siteOrientStr<dd>  ( const lefiSite * this, int index );</a></font>
      </dl>
      <p><a name="1063669">&nbsp;</a></p>
      <p><a name="1063707">The C routine prototypes for the API functions can be found in the following files:</a></p>
      <table summary="" border="0" cellpadding="4" cellspacing="0" bordercolor="#D3D3D3" width="548">
        <caption>
        <tr>
          <td cellpadding="4" valign="top" width="182">
            <p><a name="1063672">lefiArray.h</a></p>
          </td>
          <td cellpadding="4" valign="top" width="182">
            <p><a name="1063674">lefiNonDefault.h</a></p>
          </td>
          <td cellpadding="4" valign="top" width="182">
            <p><a name="1063676">lefiViaRule.h</a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1063678">lefiCrossTalk.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063680">lefrCallBacks.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063682">lefiProp.h</a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1063684">lefrReader.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063686">lefiDebug.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063688">lefiDefs.h</a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1063690">lefwWriter.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063692">lefiKRDefs.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063694">lefiLayer.h</a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1063696">lefiUnits.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063698">lefiUser.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063715">lefiMacro.h</a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1063702">lefiUtil.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063704">lefiMisc.h</a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1063706">lefiVia.h</a></p>
          </td>
        </tr>
      </table>
      <h2><a name="1064282">LEF Reader Classes</a></h2>
      <p><a name="1064479">The following table lists the classes routines that apply to the LEF information. </a></p>
      <table summary="" border="0" cellpadding="4" cellspacing="0" bordercolor="#D3D3D3" width="552">
        <caption>
        <tr>
          <td cellpadding="4" border="0" bordercolor="#D3D3D3" valign="middle" width="242">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1064285"><font color="#000000"><strong>LEF Information</strong></font></a></strong></font>
            </p>
          </td>
          <td cellpadding="4" border="0" bordercolor="#D3D3D3" valign="middle" width="309">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1064287">LEF Class</a></strong></font>
            </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1064481" title="4" name="1064292"><font color="#0000ff"><u>Layer Classes</u></font></a><font color="#000000"><strong> </strong></font></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiAntennaModel" title="4" name="1064297"><font color="#0000ff"><u>lefiAntennaModel</u></font></a> <br><a href="#lefiAntennaPWL" title="4"><font color="#0000ff"><u>lefiAntennaPWL</u></font></a><br><a href="#lefiInfluence" title="4"><font color="#0000ff"><u>lefiInfluence</u></font></a><br><a href="#lefiLayer" title="4"><font color="#0000ff"><u>lefiLayer</u></font></a><br><a href="#lefiLayerDensity" title="4"><font color="#0000ff"><u>lefiLayerDensity</u></font></a><br><a href="#lefiOrthogonal" title="4"><font color="#0000ff"><u>lefiOrthogonal</u></font></a><br><a href="#lefiParallel" title="4"><font color="#0000ff"><u>lefiParallel</u></font></a><br><a href="#lefiSpacingTable" title="4"><font color="#0000ff"><u>lefiSpacingTable</u></font></a><br><a href="#lefiTwoWidths" title="4"><font color="#0000ff"><u>lefiTwoWidths</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1037350" title="4" name="1064326"><font color="#0000ff"><u>Macro Data Classes</u></font></a><font color="#000000"><strong> </strong></font></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiDensity" title="4" name="1064331"><font color="#0000ff"><u>lefiDensity</u></font></a><br><a href="#lefiMacro" title="4"><font color="#0000ff"><u>lefiMacro</u></font></a><br><a href="#lefiMacroForeign" title="4"><font color="#0000ff"><u>lefiMacroForeign</u></font></a><br><a href="#lefiMacroSite" title="4"><font color="#0000ff"><u>lefiMacroSite</u></font></a><br><a href="#1057954" title="4"><font color="#0000ff"><u>lefiPoints</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1063842" title="4" name="1064348"><font color="#0000ff"><u>Macro Obstruction Class</u></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#1014271" title="4" name="1064353"><font color="#0000ff"><u>lefiObstruction</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#MacroPinRoutines" title="4" name="1064358"><font color="#0000ff"><u>Macro Pin Classes</u></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiGeometries" title="4" name="1064363"><font color="#0000ff"><u>lefiGeometries</u></font></a><br><a href="#lefiPin" title="4"><font color="#0000ff"><u>lefiPin</u></font></a><br><a href="#lefiPinAntennaModel" title="4"><font color="#0000ff"><u>lefiPinAntennaModel</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1037937" title="4" name="1064374"><font color="#0000ff"><u>Maximum Via Stack Class</u></font></a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiMaxStackVia" title="4" name="1064379"><font color="#0000ff"><u>lefiMaxStackVia</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1057802" title="4" name="1064384"><font color="#0000ff"><u>Miscellaneous Class</u></font></a><font color="#000000"><strong> </strong></font></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiUserData" title="4" name="1064389"><font color="#0000ff"><u>lefiUserData</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1038008" title="4" name="1064394"><font color="#0000ff"><u>Nondefault Rule Class</u></font></a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiNonDefault" title="4" name="1064399"><font color="#0000ff"><u>lefiNonDefault</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1038123" title="4" name="1064404"><font color="#0000ff"><u>Property Definition Classes</u></font></a><font color="#000000"><strong> </strong></font></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiProp" title="4" name="1064409"><font color="#0000ff"><u>lefiProp</u></font></a><br><a href="#lefiPropType" title="4"><font color="#0000ff"><u>lefiPropType</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1038189" title="4" name="1064414"><font color="#0000ff"><u>Same&#45;Net Spacing Class</u></font></a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiSpacing" title="4" name="1064419"><font color="#0000ff"><u>lefiSpacing</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1038259" title="4" name="1064424"><font color="#0000ff"><u>Site Classes</u></font></a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiSite" title="4" name="1064429"><font color="#0000ff"><u>lefiSite</u></font></a><br><a href="#lefiSitePattern" title="4"><font color="#0000ff"><u>lefiSitePattern</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1057340" title="4" name="1064437"><font color="#0000ff"><u>Units Class</u></font></a><font color="#000000"><strong> </strong></font></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#1038312" title="4" name="1064442"><font color="#0000ff"><u>lefiUnits</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1050128" title="4" name="1064447"><font color="#0000ff"><u>Use Min Spacing Class</u></font></a></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#lefiUseMinSpacing" title="4" name="1064452"><font color="#0000ff"><u>lefiUseMinSpacing</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a href="#1038345" title="4" name="1064457"><font color="#0000ff"><u>Via Classes</u></font></a><font color="#000000"><strong> </strong></font></p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a href="#1038372" title="4" name="1064462"><font color="#0000ff"><u>lefiVia</u></font></a><br><a href="#lefiViaLayer" title="4"><font color="#0000ff"><u>lefiViaLayer</u></font></a></p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a href="#1038580" title="4" name="1064470"><font color="#0000ff"><u>Via Rule Classes</u></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a href="#lefiViaRule" title="4" name="1064475"><font color="#0000ff"><u>lefiViaRule</u></font></a><br><a href="#lefiViaRuleLayer" title="4"><font color="#0000ff"><u>lefiViaRuleLayer</u></font></a></p>
          </td>
        </tr>
      </table>
      <h2><a name="1064481">Layer Classes</a></h2>
      <p><a name="1064069">The LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> routines include the following classes:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiAntennaModel" title="4" name="1064073"><font color="Blue"><u>lefiAntennaModel</u></font></a><a href="#lefiAntennaModel" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiAntennaPWL" title="4" name="1057924"><font color="Blue"><u>lefiAntennaPWL</u></font></a><a href="#lefiAntennaPWL" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiInfluence" title="4" name="1057529"><font color="Blue"><u>lefiInfluence</u></font></a><a href="#lefiInfluence" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiLayer" title="4" name="1050082"><font color="Blue"><u>lefiLayer</u></font></a><a href="#lefiLayer" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiLayerDensity" title="4" name="1037187"><font color="Blue"><u>lefiLayerDensity</u></font></a><a href="#lefiLayerDensity" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiOrthogonal" title="4" name="1058773"><font color="Blue"><u>lefiOrthogonal</u></font></a><a href="#lefiOrthogonal" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiParallel" title="4" name="1057534"><font color="Blue"><u>lefiParallel</u></font></a><a href="#lefiParallel" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiSpacingTable" title="4" name="1057539"><font color="Blue"><u>lefiSpacingTable</u></font></a><a href="#lefiSpacingTable" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiTwoWidths" title="4" name="1058814"><font color="Blue"><u>lefiTwoWidths</u></font></a><a href="#lefiTwoWidths" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiAntennaModel"></a><a name="1057553">lefiAntennaModel</a></h3>
      <p><a name="1057554">Retrieves antenna model information from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> section of the LEF file.</p>
      <p><a name="1057559">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> sections, see <a href="../lefdefref/LEFSyntax.html#Layer(Cut)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Cut),&#34;</u></font></a> and <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1057563">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058562">class lefiAntennaModel {<dd>int hasAntennaAreaRatio() const;<dd>int hasAntennaDiffAreaRatio() const; <dd>int hasAntennaDiffAreaRatioPWL() const;<dd>int hasAntennaCumAreaRatio() const;<dd>int hasAntennaCumDiffAreaRatio() const<dd>int hasAntennaCumDiffAreaRatioPWL() const;<dd>int hasAntennaAreaFactor() const;<dd>int hasAntennaAreaFactorDUO() const;<dd>int hasAntennaSideAreaRatio() const;<dd>int hasAntennaDiffSideAreaRatio() const;<dd>int hasAntennaDiffSideAreaRatioPWL() const;<dd>int hasAntennaCumSideAreaRatio() const;<dd>int hasAntennaCumDiffSideAreaRatio() const;<dd>int hasAntennaCumDiffSideAreaRatioPWL() const;<dd>int hasAntennaSideAreaFactor() const;<dd>int hasAntennaSideAreaFactorDUO() const;<dd>int hasAntennaCumRoutingPlusCut() const;<dd>int hasAntennaGatePlusDiff() const;<dd>int hasAntennaAreaMinusDiff() const;<dd>int hasAntennaAreaDiffReducePWL() const; <dd><dd>char* antennaOxide() const;<dd>double antennaAreaRatio() const;<dd>double antennaDiffAreaRatio() const;<dd></a><font color="#0000ff"><u>lefiAntennaPWL</u></font>* antennaDiffAreaRatioPWL() const;<dd>double antennaCumAreaRatio() const;<dd>double antennaCumDiffAreaRatio() const;<dd>lefiAntennaPWL* antennaCumDiffAreaRatioPWL() const;<dd>double antennaAreaFactor() const;<dd>double antennaSideAreaRatio() const;<dd>double antennaDiffSideAreaRatio() const;<dd>lefiAntennaPWL* antennaDiffSideAreaRatioPWL() const;<dd>double antennaCumSideAreaRatio() const;<dd>double antennaCumDiffSideAreaRatio() const;<dd>lefiAntennaPWL* antennaCumDiffSideAreaRatioPWL() const;<dd>double antennaSideAreaFactor() const; <dd>double antennaGatePlusDiff() const;<dd>double antennaAreaMinusDiff() const;<dd>lefiAntennaPWL* antennaAreaDiffReducePWL() const; };</font>
      </dl>
      <h3><a name="lefiAntennaPWL"></a><a name="1050083">lefiAntennaPWL</a></h3>
      <p><a name="1050084">Retrieves antenna Piece&#45;wise Linear Format (PWL) data from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> section of the LEF file. </p>
      <p><a name="1053188">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> sections, see <a href="../lefdefref/LEFSyntax.html#Layer(Cut)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Cut),&#34;</u></font></a> and <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1050199">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1050085">class lefiAntennaPWL {<dd>int numPWL() const;<dd>double PWLdiffusion(int index):<dd>double PWLratio(int index); };</a></font>
      </dl>
      <h3><a name="lefiInfluence"></a><a name="1057481">lefiInfluence</a></h3>
      <p><a name="1057482">Retrieves influence rule information from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section of the LEF file.</p>
      <p><a name="1057484">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section, see <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1057485">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057486">class lefiInfluence {<dd>int numInfluenceEntry() const;<dd>double width(int index) const;<dd>double distance(int index) const;<dd>double spacing(int index) const; };</a></font>
      </dl>
      <h3><a name="lefiLayer"></a><a name="1037159">lefiLayer</a></h3>
      <p><a name="1032883">Retrieves data from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> section of the LEF file. This callback can be used for all layer types (cut, masterslice, implant, and routing). However, most of these functions apply to routing layers. Comments in the C++ syntax indicate those arguments that apply only to a particular layer type. All other arguments apply to all layer types.</p>
      <p><a name="1032885">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> sections, see <a href="../lefdefref/LEFSyntax.html#Layer(Cut)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Cut),&#34;</u></font></a> <a href="../lefdefref/LEFSyntax.html#Layer(MastersliceorOverlap)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Masterslice or Overlap),&#34;</u></font></a> and <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1014190">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1060477">class lefiLayer {<dd>int hasType() const;<dd>int hasPitch() const;                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing<dd>int hasXYPitch() const;<dd>int hasOffset() const;               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <dd>int hasXYOffset() const;<dd>int hasWidth() const;                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <dd>int hasArea() const;<dd>int hasDiagPitch() const;<dd>int hasXYDiagPitch() const;<dd>int hasDiagWidth() const;<dd>int hasDiagSpacing() const;<dd>int hasSpacingNumber() const;         <dd>int hasSpacingName(int index) const;<dd>int hasSpacingLayerStack(int index) const;<dd>int hasSpacingAdjacent(int index) const;<dd>int hasSpacingCenterToCenter(int index) const;<dd>int hasSpacingRange(int index) const; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <dd>int hasSpacingRangeUseLengthThreshold(int index) const;<dd>int hasSpacingRangeInfluence(int index) const;<dd>int hasSpacingRangeInfluenceRange(int index) const;<dd>int hasSpacingRangeRange(int index) const;<dd>int hasSpacingLengthThreshold(int index) const; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing<dd>int hasSpacingLengthThresholdRange(int index) const; &nbsp;&nbsp;&nbsp;&#47;&#47; Routing<dd>int hasSpacingParallelOverlap(int index) const;<dd>int hasSpacingArea(int index) const;<dd>int hasSpacingEndOfLine(int index) const;<dd>int hasSpacingParellelEdge(int index) const;<dd>int hasSpacingTwoEdges(int index) const;<dd>int hasSpacingAdjacentExcept(int index) const;<dd>int hasSpacingSamenet(int index) const;<dd>int hasSpacingSamenetPGonly(int index) const;<dd>int hasSpacingNotchLength(int index) const;<br>int hasSpacingEndOfNotchWidth(int index) const;<br>int hasDirection() const;            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasResistance() const;           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasResistanceArray() const;<br>int hasCapacitance() const;          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasCapacitanceArray() const;<br>int hasHeight() const;               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasThickness() const;            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasWireExtension() const;         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasShrinkage() const;            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasCapMultiplier() const;        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasEdgeCap() const;              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasAntennaLength() const;        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasAntennaArea() const;          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>int hasCurrentDensityPoint() const; <br>int hasCurrentDensityArray() const;<br>int hasAccurrentDensity() const; <br>int hasDccurrentDensity() const; <br><br>int numProps() const;<br>const char* propName(int index) const;<br>const char* propValue(int index) const;<br>double propNumber(int index) const;<br>const char propType(int index) const;<br>int propIsNumber(int index) const;<br>int propIsString(int index) const;<br><br>int numSpacing() const;          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Cut and Routing<br><br>char* name() const;<br>const char* type() const;<br>double pitch() const;                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double pitchX() const;<br>double pitchY() const;<br>double offset() const;                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double offsetX() const;<br>double offsetY() cont;<br>double width() const;                   <br>double area() const;<br>double diagPitch() const;<br>double diagPitchX() const;<br>double diagPitchY() const;<br>double diagWidth() const;<br>double diagSpacing() const;<br>double spacing(int index) const;       <br>char*  spacingName(int index) const;    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Cut<br>int spacingAdjacentCuts(int index) const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Cut<br>double spacingAdjacentWithin(int index) const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Cut<br>double spacingArea(int index) const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Cut<br>double spacingRangeMin(int index) const;  <br>double spacingRangeMax(int index) const;  <br>double spacingRangeInfluence(int index) const;<br>double spacingRangeInfluenceMin(int index) const;<br>double spacingRangeInfluenceMax(int index) const;<br>double spacingRangeRangeMin(int index) const;<br>double spacingRangeRangeMax(int index) const;<br>double spacingLengthThreshold(int index) const;<br>double spacingLengthThresholdRangeMin(int index) const;<br>double spacingLengthThresholdRangeMax(int index) const;<br><br>double spacingEolWidth(int index) const;<br>double spacingEolWithin(int index) const;<br>double spacingParSpace(int index) const;<br>double spacingParWithin(int index) const;<br><br>double spacingNotchLength(int index) const;<br>double spacingEndOfNotchWidth(int index) const;<br>double spacingEndOfNotchSpacing(int index) const;<br>double spacingEndOfNotchLength(int index) const;<br><br>int numMinimumcut() const;<br>int minimumcut(int index) const;<br>double minimumcutWidth(int index) const;<br>int hasMinimumcutWithin(int index) const;<br>double minimumcutWithin(int index) const;<br>int hasMinimumcutConnection(int index) const; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; FROMABOVE | FROMBELOW<br>const char* minimumcutConnection(int index) const; &#47;&#47; FROMABOVE | FROMBELOW<br>int hasMinimumcutNumCuts(int index) const;<br>double minimumcutLength(int index) const;<br>double minimumcutDistance(int index) const;<br><br>const char* direction() const;         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double resistance() const;             &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double capacitance() const;           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double height() const;                 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double wireExtension() const;          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double thickness() const;              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double shrinkage() const;              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double capMultiplier() const;          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double edgeCap() const;                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double antennaLength() const;          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double antennaArea() const;            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br>double currentDensityPoint() const;     <br>void currentDensityArray(int* numPoints, double** widths,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double** current) const;  <br>void capacitanceArray(int* numPoints, double** widths,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double** resValues) const;  <br>void resistanceArray(int* numPoints, double** widths,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double** capValues) const; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Routing <br><br>int numAccurrentDensity() const;<br></a><font color="#0000ff"><u>lefiLayerDensity</u></font>* accurrent(int index) const;<br>int numDccurrentDensity() const;<br>lefiLayerDensity* dccurrent(int index) const;<br><br>int numAntennaModel() const;<br><font color="#0000ff"><u>lefiAntennaModel</u></font>* antennaModel(int index) const;<br><br>int hasSlotWireWidth() const;<br>int hasSlotWireLength() const;<br>int hasSlotWidth() const;<br>int hasSlotLength() const;<br>int hasMaxAdjacentSlotSpacing() const;<br>int hasMaxCoaxialSlotSpacing() const;<br>int hasMaxEdgeSlotSpacing() const;<br>int hasSplitWireLength() const;<br>int hasMinimumDensity() const;<br>int hasMaximumDensity() const;<br>int hasDensityCheckWindow() const;<br>int hasDensityCheckStep() const;<br>int hasFillActiveSpacing() const;<br>int hasMaxwidth() const;<br>int hasMinwidth() const; <br>int hasMinstep() const;<br>int hasProtrusion() const;<br><br>double slotWireWidth() const;<br>double slotWireLength() const;<br>double slotWidth() const;<br>double slotLength() const;<br>double maxAdjecentSlotSpacing() const;<br>double maxCoaxialSlotSpacing() const;<br>double maxEdgeSlotSpacing() const;<br>double splitWireLength() const;<br>double minimumDensity() const<br>double maximumDensity() const;<br>double densityCheckWindowLength() const;<br>double densityCheckWindowWidth() const;<br>double densityCheckStep() const;<br>double fillActiveSpacing() const;<br>double maxwidth() const;<br>double minwidth() const;<br>double minstep() const;<br>double protrusionWidth1() const;<br>double protrusionLength() const;<br>double protrusionWidth2() const;<br><br>int numMistep() const;<br>double minstep(int index) const;<br>int hasMinstepType(int index) const;<br>char* minstepType(int index) const;<br>int hasMinstepLengthsum(int index) const;<br>double minstepLengthsum(int index) const;<br>int hasMinstepMaxedges(int index) const;<br>int minstepMaxedges(int index) const;<br><br>int numMinenclosedarea() const;<br>double minenclosedarea(int index) const;<br>int hasMinenclosedareaWidth(int index) const;<br>double minenclosedareaWidth(int index) const;<br><br>int numSpacingTable();<br><font color="#0000ff"><u>lefiSpacingTable</u></font>* spacingTable(int index);<br><br>int numEnclosure() const;<br>int hasEnclosureRule(int index) const;<br>char* enclosureRule (int index);<br>double enclosureOverhang1(int index) const;<br>double enclosureOverhang2(int index) const;<br>int hasEnclosureWidth(int index) const;<br>double enclosureMinWidth(int index) const;<br>int hasEnclosureExceptExtraCut(int index) const;<br>double enclosureExceptExtraCut(int index) const;<br>int hasEnclosureMinLength(int index) const;<br>double enclosureMinLength(int index) const;<br>int numPreferEnclosure() const;<br>int hasPreferEnclosureRule(int index) const;<br>char* preferEnclosureRule(int index) const;<br>double preferEnclosureOverhang1(int index) const;<br>double preferEnclosureOverhang2(int index) const;<br>int hasPreferEnclosureWidth(int index) const;<br>double preferEnclosureMinWidth(int index) const;<br>int hasResistancePerCut() const;<br>double resistancePerCut() const;<br>int hasMinEdgeLength() const;<br>double minEdgeLength() const;<br>int hasDiagMinEdgeLength() const;<br>double diagMinEdgeLength() const; <br>int hasMinSize() const;<br>int numMinSize() const;<br>double minSizeWidth(int index) const;<br>double minSizeLength(int index)const ; <br><br>int hasMaxFloatingArea() const;<br>double maxFloatingArea() const;<br>int hasArraySpacing() const;<br>int hasLongArray() const;<br>int hasViaWidth() const;<br>double viaWidth() const;<br>double cutSpacing() const;<br>int numArrayCuts() const;<br>int arrayCuts(int index) const;<br>double arraySpacing(int index) const;<br>int hasSpacingTableOrtho() const;<br><a href="#lefiOrthogonal" title="4"><font color="#0000ff"><u>lefiOrthogonal</u></font></a> *orthogonal() const; <br><br>int hasMask() const; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Check the layer has color mask assigned or not.  <br>int mask() const;	 }; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; Return the color mask number of the layer.</font>
      </dl>
      <h3><a name="lefiLayerDensity"></a><a name="1058979">lefiLayerDensity</a></h3>
      <p><a name="1037340">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">LAYERDENSITY</font> statement in a <font size="2" face="'Courier New'" color="#000000">LAYER</font> section of the LEF file.</p>
      <p><a name="1053204">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> sections, see <a href="../lefdefref/LEFSyntax.html#Layer(Cut)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Cut),&#34;</u></font></a> and <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1037341">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058283">class lefiLayerDensity {<dd>  char* type();<dd>  int hasOneEntry();<dd>  double oneEntry();<dd>  int numFrequency();<dd>  double frequency(int index);<dd>  int numWidths();<dd>  double width(int index);<dd>  int numTableEntries();<dd>  double tableEntry(int index);<dd>  int numCutareas();<dd>  double cutArea(int index); };</a></font>
      </dl>
      <h3><a name="lefiOrthogonal"></a><a name="1058774">lefiOrthogonal</a></h3>
      <p><a name="1058775">Retrieves orthogonal spacing information from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> section of the LEF file.</p>
      <p><a name="1058880">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> sections, see <a href="../lefdefref/LEFSyntax.html#Layer(Cut)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Cut)</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1058783">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058781">class lefiOrthogonal {<dd>int  numOrthogonal() const;<dd>double cutWithin(int index) const;<dd>double orthoSpacing(int index) const; };</a></font>
      </dl>
      <h3><a name="lefiParallel"></a><a name="1057495">lefiParallel</a></h3>
      <p><a name="1057496">Retrieves parallel run length information from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section of the LEF file. </p>
      <p><a name="1057498">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section, see <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1057499">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057500">class lefiParallel {<dd>int numLength() const;<dd>int numWidth() const;<dd>double length(int iLength) const;<dd>double width(int iWidth) const;<dd>double widthSpacing(int iWidth, int iWidthSpacing) const; };</a></font>
      </dl>
      <h3><a name="lefiSpacingTable"></a><a name="1057501">lefiSpacingTable</a></h3>
      <p><a name="1057502">Retrieves spacing table information from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section of the LEF file. </p>
      <p><a name="1057504">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section, see <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1057505">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057524">class lefiSpacingTable {<dd>int isInfluence() const;<dd></a><font color="#0000ff"><u>lefiInfluence</u></font>* influence() const;<dd>int isParallel() const;<dd><font color="#0000ff"><u>lefiParallel</u></font>* parallel() const; <dd><a href="#lefiTwoWidths" title="4"><font color="#0000ff"><u>lefiTwoWidths</u></font></a>* twoWidths() const; };</font>
      </dl>
      <h3><a name="lefiTwoWidths"></a><a name="1058853">lefiTwoWidths</a></h3>
      <p><a name="1058854">Retrieves two&#45;width spacing information from a </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section of the LEF file.</p>
      <p><a name="1058898">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> (Routing) section, see <a href="../lefdefref/LEFSyntax.html#Layer(Routing)" target="external_window"><font color="#0000ff"><u>&#34;Layer (Routing)&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1058856">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058851">class lefiTwoWidths {<dd>int numWidth() const;<dd>double width(int iWidth) const;<dd>int hasWidthPRL(int iWidth) const;<dd>double widthPRL(int iWidth) const;<dd>int numWidthSpacing(int iWidth) const;<dd>double widthSpacing(int iWidth, int iWidthSpacing) const; };</a></font>
      </dl>
      <h2><a name="1037350">Macro Data Classes</a></h2>
      <p><a name="1037351">The LEF </a><font size="2" face="'Courier New'" color="#000000">MACRO</font> data routines include the following LEF classes:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiDensity" title="4" name="1037355"><font color="Blue"><u>lefiDensity</u></font></a><a href="#lefiDensity" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiMacro" title="4" name="1058152"><font color="Blue"><u>lefiMacro</u></font></a><a href="#lefiMacro" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiMacroForeign" title="4" name="1063067"><font color="Blue"><u>lefiMacroForeign</u></font></a><a href="#lefiMacroForeign" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiMacroSite" title="4" name="1063089"><font color="Blue"><u>lefiMacroSite</u></font></a><a href="#lefiMacroSite" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1057954" title="4" name="1057953"><font color="Blue"><u>lefiPoints</u></font></a><a href="#1057954" title="4"></a> </td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiDensity"></a><a name="1058137">lefiDensity</a></h3>
      <p><a name="1058138">Retrieves density information from the </a><font size="2" face="'Courier New'" color="#000000">MACRO</font> section of the LEF file.</p>
      <p><a name="1058171">For syntax information about the </a><font size="2" face="'Courier New'" color="#000000">MACRO</font> section, see <a href="../lefdefref/LEFSyntax.html#Macro" target="external_window"><font color="#0000ff"><u>&#34;Macro&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1058141">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058142">class lefiDensity {<dd>int numLayer() const;<dd>char* layerName(int index) const;<dd>int numRects(int index) const;<dd>struct lefiGeomRect getRect(int index, int rectIndex) const;<dd>double densityValue(int index, int rectIndex) const; };</a></font>
      </dl>
      <h3><a name="lefiMacro"></a><a name="1037347">lefiMacro</a></h3>
      <p><a name="1032910">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">MACRO</font> section of the LEF file. </p>
      <p><a name="1032914">For syntax information about the </a><font size="2" face="'Courier New'" color="#000000">MACRO</font> section, see <a href="../lefdefref/LEFSyntax.html#Macro" target="external_window"><font color="#0000ff"><u>&#34;Macro&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1014212">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1014213">class lefiMacro {<dd>int hasClass() const;<dd>int hasGenerator() const;<dd>int hasGenerate() const;<dd>int hasPower() const;<dd>int hasOrigin() const;<dd>int hasEEQ() const;<dd>int hasLEQ() const;<dd>int hasSource() const;<dd>int hasXSymmetry() const;<dd>int hasYSymmetry() const;<dd>int has90Symmetry() const;<dd>int hasSiteName() const;<dd>int hasSitePattern() const;<dd>int hasSize() const;<dd>int hasForeign() const;<dd>int hasForeignOrigin(int index = 0) const;<dd>int hasForeignOrient(int index = 0) const;<dd>int hasForeignPoint(int index = 0) const;<dd>int hasClockType() const;<dd>int isBuffer() const;<dd>int isInverter() const;</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1014214">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numSitePattern() const;<dd>int numProperties() const;<dd>const char* propName(int index) const;<dd>const char* propValue(int index) const;<dd>double propNum(int index) const;<dd>const char propType(int index) const;<dd>int propIsNumber(int index) const;<dd>int propIsString(int index) const;</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1014215">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char* name() const;<dd>const char* macroClass() const;<dd>const char* generator() const;<dd>const char* EEQ() const;<dd>const char* LEQ() const;<dd>const char* source() const;<dd>const char* clockType() const;<dd>double originX() const;<dd>double originY() const;<dd>double power() const;<dd>void generate(char** name1, char** name2) const;<dd>lefiSitePattern* sitePattern(int index) const;<dd>const char* siteName() const;<dd>double sizeX() const;<dd>double sizeY() const;<dd>int numForeigns() const;<dd>int foreignOrient(int index = 0) const;&nbsp;&nbsp;&nbsp;&#47;&#47;optional &#45; for information, see<dd>							  &nbsp;    &#47;&#47;</a><a href="ch1Intro.html#1019049" title="1"><font color="DodgerBlue"><u>Orientation Codes</u></font></a><a href="ch1Intro.html#1019049" title="1"> </a> <dd>const char* foreignOrientStr(int index = 0) const;<dd>double foreignX(int index = 0) const;<dd>double foreignY(int index = 0) const;<dd>const char* foreignName(int index = 0) const; };</font>
      </dl>
      <h3><a name="lefiMacroForeign"></a><a name="1062978">lefiMacroForeign</a></h3>
      <p><a name="1062979">Retrieves data for in&#45;place processing of a </a><font size="2" face="'Courier New'" color="#000000">MACRO FOREIGN</font> statement. </p>
      <h4><a name="1062980">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1063241">class lefiMacroForeign {<dd>public:<dd>             lefiMacroForeign(const char *name,<dd>                              int        hasPts,<dd>                              double     x,<dd>                              double     y,<dd>                              int        hasOrient,<dd>                              int        orient);<dd><dd>  const char *cellName() const;<dd>  int        cellHasPts() const;<dd>  double     px() const;<dd>  double     py() const;<dd>  int        cellHasOrient() const;<dd>  int        cellOrient() const;<dd><dd>protected:<dd>  const char *cellName_;<dd>  int        cellHasPts_;<dd>  double     px_;<dd>  double     py_;<dd>  int        cellHasOrient_;<dd>  int        cellOrient_;<dd>};</a></font>
      </dl>
      <h3><a name="lefiMacroSite"></a><a name="1063114">lefiMacroSite</a></h3>
      <p><a name="1063115">Retrieves data for in&#45;place processing of a </a><font size="2" face="'Courier New'" color="#000000">MACRO SITE</font> statement. </p>
      <h4><a name="1063116">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1063607">class lefiMacroSite {<dd>public:<dd>                lefiMacroSite(const char *name, const lefiSitePattern* pattern);<dd><dd>  const char            *siteName() const;<dd>  const lefiSitePattern *sitePattern() const;<dd><dd>protected:<dd>  const char            *siteName_;<dd>  const lefiSitePattern *sitePattern_;<dd>};</a></font>
      </dl>
      <h3><a name="1057954">lefiPoints</a></h3>
      <p><a name="1057955">Returns the X and Y points for the </a><font size="2" face="'Courier New'" color="#000000">ORIGIN</font> and <font size="2" face="'Courier New'" color="#000000">SIZE</font> statements in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section. </p>
      <h4><a name="1057960">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057961">struct lefiPoints {<dd>double x;<dd>double y; };</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057962">typedef struct lefiPoints lefiNum;</a></font>
      </dl>
      <h3><a name="1037366">Macro Examples</a></h3>
      <p><a name="1037367">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrMacroBeginCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">const char*</font>.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037368">int macroBeginCB (lefrCallbackType_e type,<dd>                  const char *macroName,<dd>                  lefiUserData userData) {<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037369">    &nbsp;&#47;&#47; Incorrect type was passed in, expecting the type<dd>&#47;&#47; lefiMacroBeginCbkType<dd>    if (type != lefiMacroBeginCbkType) {<dd>        printf(&#34;Type is not lefiMacroBeginCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037370">    &#47;&#47; Expect a non null char* macroName<dd>    if (!macroName || !*macroName) {<dd>        printf(&#34;Macro name is null, terminate parsing.\n&#34;);<dd>        return 1;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1053207">    &#47;&#47; Write out the macro name<dd>    printf(&#34;Macro name is %s\n&#34;, macroName);<dd>    return 0;}<dd></a></font>
      </dl>
      <p><a name="1037372">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrMacroCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiMacro</font>. This example only shows how to retrieve part of the data from the <font size="2" face="'Courier New'" color="#000000">lefiMacro</font> class.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037373">int macroCB (lefrCallbackType_e type,<dd>             lefiMacro *macroInfo,<dd>             lefiUserData userData) {<dd><dd>    int              propNum, i, hasPrtSym = 0;<dd>    lefiSitePattern* pattern;<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037374">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrMacroCbkType) {<dd>        printf(&#34;Type is not lefrMacroCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;<dd>    }<dd><dd>    if (macroInfo&#45;&#62;hasClass())<dd>       printf(&#34;  CLASS %s\n&#34;, macroInfo&#45;&#62;macroClass());<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037375">    if (macroInfo&#45;&#62;hasXSymmetry()) {<dd>       printf(&#34;  SYMMETRY X &#34;);<dd>       hasPrtSym = 1;<dd>    }<dd>    if (macroInfo&#45;&#62;hasYSymmetry()) {  &nbsp;&#47;&#47; print X Y &amp; R90 in one line<dd><dd>       if (!hasPrtSym) {              &nbsp;&#47;&#47; the line has not started yet<dd>          printf(&#34;  SYMMETRY Y &#34;);<dd>          hasPrtSym = 1;<dd>       }<dd>       else                            &#47;&#47; the line has already started<dd>          printf(&#34;Y &#34;);<dd>    }<dd>    if (macroInfo&#45;&#62;has90Symmetry()) {<dd>       if (!hasPrtSym) {               &#47;&#47; the line has not started yet<dd>          printf(&#34;  SYMMETRY R90 &#34;);<dd>          hasPrtSym = 1;<dd>       }<dd>       else                            &#47;&#47; the line has already started<dd>          printf(&#34;R90 &#34;);<dd>    }<dd>    if (hasPrtSym) {<dd>        printf (&#34;\n&#34;);<dd>        hasPrtSym = 0;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037376">    &#47;&#47; Check if SITE pattern is defined in the macro<dd>    if (macroInfo&#45;&#62;hasSitePattern()) {<dd>        for (i = 0; i &#60; macroInfo&#45;&#62;numSitePattern(); i++ ) {<dd>            pattern = macroInfo&#45;&#62;sitePattern(i);<dd>            printf(&#34;  SITE %s %g %g %d DO %g BY %g STEP %g %g\n&#34;,<dd>                   pattern&#45;&#62;name(), pattern&#45;&#62;x(), pattern&#45;&#62;y(),<dd>                   pattern&#45;&#62;orient(), pattern&#45;&#62;xStart(), <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pattern&#45;&#62;yStart(),<dd>                   pattern&#45;&#62;xStep(), pattern&#45;&#62;yStep());<dd>        }<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037377">    &#47;&#47; Check if PROPERTY is defined in the macro<dd>    propNum = macroInfo&#45;&#62;numProperties();<dd>    if (propNum &#62; 0) {<dd>        printf(&#34;  PROPERTY &#34;);<dd>        for (i = 0; i &#60; propNum; i++) {<dd>            &#47;&#47; value can either be a string or number<dd>            if (macroInfo&#45;&#62;propValue(i)) {<dd>                printf(&#34;%s %s &#34;, macroInfo&#45;&#62;propName(i),<dd>                       macroInfo&#45;&#62;propValue(i));<dd>            }<dd>            else<dd>                printf(&#34;%s %g &#34;, macroInfo&#45;&#62;propName(i),<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;macroInfo&#45;&#62;propNum(i));<dd>        }<dd>        printf(&#34;\n&#34;);<dd><dd>    }<dd>    return 0;}</a></font>
      </dl>
      <h2><a name="1063842">Macro Obstruction Class</a></h2>
      <p><a name="1063843">The LEF Macro Obstruction routines include the following LEF class:</a></p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1014271" title="4" name="1063847"><font color="Blue"><u>lefiObstruction</u></font></a><a href="#1014271" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiMinFeature"></a><a name="lefiObstruction"></a><a name="1014271">lefiObstruction</a></h3>
      <p><a name="1033037">Retrieves data from the Macro Obstruction (</a><font size="2" face="'Courier New'" color="#000000">OBS</font>) statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section of the LEF file. The Macro Obstruction statement defines sets of obstructions (blockages) on the macro. </p>
      <p><a name="1033041">For syntax information about the Macro Obstruction statement, see </a><a href="../lefdefref/LEFSyntax.html#MacroObstructionStatement" target="external_window"><font color="#0000ff"><u>&#34;Macro Obstruction Statement&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1014272">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1014273">class lefiObstruction {<dd></a><font color="#0000ff"><u>lefiGeometries</u></font>* geometries() const;};</font>
      </dl>
      <h3><a name="1037465">Macro Obstruction Examples</a></h3>
      <p><a name="1037466">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrObstructionCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiObstruction</font>.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1050756">int macroObsCB (lefrCallbackType_e type,<dd>lefiObstruction* obsInfo,<dd>lefiUserData userData) {<dd><dd>lefiGeometries*       geometry;<dd>int                   numItems;<dd>int                   i, j;<dd>lefiGeomPath*         path;<dd>lefiGeomPathIter*     pathIter;<dd>lefiGeomRect*         rect;<dd>lefiGeomRectIter*     rectIter;<dd>lefiGeomPolygon*      polygon;<dd>lefiGeomPolygonIter*  polygonIter;<dd>lefiGeomVia*          via;<dd>lefiGeomViaIter*      viaIter;<dd><dd>&#47;&#47; Check if the type is correct<dd>    if (type != lefrObstructionCbkType) {<dd>        printf(&#34;Type is not lefrObstructionCbkType, <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate parsing.\n&#34;);<dd>        return 1;}<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1063825">    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&#34;OBS\n&#34;);<dd>    geometry = obs&#45;&#62;geometries();<dd>    numItems = geometry&#45;&#62;numItems();<dd><dd>    for (i = 0; i &#60; numItems; i++) {<dd>        switch (geometry&#45;&#62;itemType(i)) {<dd>            case lefiGeomClassE:<dd>                 printf(&#34;   CLASS %s\n&#34;, geometry&#45;&#62;getClass(i));<dd>                 break;<dd>            case lefiGeomLayerE:<dd>                 printf(&#34;   LAYER %s\n&#34;, geometry&#45;&#62;getLayer(i));<dd>                 break;<dd>            case lefiGeomWidthE:<dd>                 printf(&#34;   WIDTH %g\n&#34;, geometry&#45;&#62;getWidth(i))<dd>                 break;<dd>            case lefiGeomPathE:<dd>                 path = geometry&#45;&#62;getPath(i);<dd>                 printf(&#34;   PATH&#34;);<dd>                 for (j = 0; j &#60; path&#45;&#62;numPoints; j++)<dd>                     printf(&#34; ( %g %g )&#34;, path&#45;&#62;x[j], path&#45;&#62;y[j]);<dd>                 printf(&#34;\n&#34;);<dd>                 break;<dd>            case lefiGeomPathIterE:<dd>                 pathIter = geometry&#45;&#62;getPathIter(i);<dd>                 printf(&#34;   PATH ITERATED&#34;);<dd>                 for (j = 0; j &#60; pathIter&#45;&#62;numPoints; j++)<dd>                     printf(&#34; ( %g %g )&#34;, pathIter&#45;&#62;x[j], <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathIter &#45;&#62;y[j]);<dd>                 printf(&#34;\n&#34;);<dd>                 printf(&#34;   DO %g BY %g STEP %g %g\n&#34;, <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathIter&#45;&#62;xStart, pathIter&#45;&#62;yStart, <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathIter&#45;&#62;xStep, pathIter&#45;&#62;yStep);<dd>                 break;<dd>            case lefiGeomRectE:<dd>                 rect = geometry&#45;&#62;getRect(i);<dd>                 printf(&#34;   RECT ( %g %g ) ( %g %g )\n&#34;, rect&#45;&#62;xl,<dd>                        rect&#45;&#62;yl, rect&#45;&#62;xh, rect&#45;&#62;yh);<dd>                 break;<br>            case lefiGeomRectIterE:<br>                 rectIter = geometry&#45;&#62;getRectIter(i);<br>                 printf(&#34;   RECT ITERATE ( %g %g ) ( %g %g )\n&#34;,<br> 					rectIter&#45;&#62;xl, rectIter&#45;&#62;yl, <br>					rectIter&#45;&#62;xh, rectIter&#45;&#62;yh);<br>                 printf(&#34;   DO %g BY %g STEP %g %g\n&#34;, <br>					rectIter&#45;&#62;xStart, rectIter&#45;&#62;yStart, <br>					rectIter&#45;&#62;xStep, rectIter&#45;&#62;yStep);<br>                 break;<br>            case lefiGeomPolygonE:<br>                 polygon = geometry&#45;&#62;getPolygon(i);<br>                 printf(&#34;   POLYGON&#34;);<br>                 for (j = 0; j &#60; polygon&#45;&#62;numPoints; j++)<br>                     printf(&#34; ( %g %g )&#34;, polygon&#45;&#62;x[j], polygon&#45;<br>					&#62;y[j]);<br>                 printf(&#34;\n&#34;);<br>                 break;<br>            case lefiGeomPolygonIterE:<br>                 polygonIter = geometry&#45;&#62;getPolygonIter(i);<br>                 printf(&#34;   POLYGON ITERATE&#34;);<br>                 for (j = 0; j &#60; polygonIter&#45;&#62;numPoints; j++)<br>                    printf(&#34; ( %g %g )&#34;, polygonIter&#45;&#62;x[j],<br>					polygonIter&#45;&#62;y[j]);<br>                 printf(&#34;\n&#34;);<br>                 printf(&#34;   DO %g BY %g STEP %g %g\n&#34;, <br>					polygonIter&#45;&#62;xStart, polygonIter&#45;&#62;yStart,<br> 					polygonIter&#45;&#62;xStep, polygonIter&#45;&#62;yStep);<br>                 break;<br>            case lefiGeomViaE:<br>                 via = geometry&#45;&#62;getVia(i);<br>                 printf(&#34;   VIA ( %g %g ) %s\n&#34;, via&#45;&#62;x,<br> 					via&#45;&#62;y, via&#45;&#62;name);<br>                 break;<br>            case lefiGeomViaIterE:<br>                 viaIter = geometry&#45;&#62;getViaIter(i);<br>                 printf(&#34;   VIA ITERATE ( %g %g ) %s\n&#34;,<br> 					viaIter&#45;&#62;x, viaIter&#45;&#62;y, viaIter&#45;&#62;name);<br>                 printf(&#34;   DO %g BY %g STEP %g %g\n&#34;, <br>					viaIter&#45;&#62;xStart, viaIter&#45;&#62;yStart, <br>					viaIter&#45;&#62;xStep, viaIter&#45;&#62;yStep);<br>                 break;<br>        }<br>    }<br>    return 0; }</a></font>
      </dl>
      <h2><a name="MacroPinRoutines"></a><a name="1063828">Macro Pin Classes</a></h2>
      <p><a name="1063829">The LEF Macro Pin routines include the following LEF classes:</a></p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiPin" title="4" name="1037486"><font color="Blue"><u>lefiPin</u></font></a><a href="#lefiPin" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiPinAntennaModel" title="4" name="1057639"><font color="Blue"><u>lefiPinAntennaModel</u></font></a><a href="#lefiPinAntennaModel" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiGeometries" title="4" name="1037490"><font color="Blue"><u>lefiGeometries</u></font></a><a href="#lefiGeometries" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiPin"></a><a name="1037463">lefiPin</a></h3>
      <p><a name="1037543">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">PIN</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section of the LEF file. <font size="2" face="'Courier New'" color="#000000">MACRO</font> <font size="2" face="'Courier New'" color="#000000">PIN</font> statements are included in the LEF file for each macro. </p>
      <p><a name="1039522">For syntax information about the Macro Pin statement, see </a><a href="../lefdefref/LEFSyntax.html#MacroPinStatement" target="external_window"><font color="#0000ff"><u>&#34;Macro Pin Statement&#34;</u></font></a> in the <br><font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1014280">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1050780">class lefiPin {<dd>int hasForeign() const;<dd>int hasForeignOrient(int index = 0) const;<dd>int hasForeignPoint(int index = 0) const;<dd>int hasLEQ() const;<dd>int hasDirection() const;<dd>int hasUse() const;<dd>int hasShape() const;<dd>int hasMustjoin() const;<dd>int hasOutMargin() const;<dd>int hasOutResistance() const;<dd>int hasInMargin() const;<dd>int hasPower() const;<dd>int hasLeakage() const;<dd>int hasMaxload() const;<dd>int hasMaxdelay() const;<dd>int hasCapacitance() const;<dd>int hasResistance() const;<dd>int hasPulldownres() const;<dd>int hasTieoffr() const;<dd>int hasVHI() const;<dd>int hasVLO() const;<dd>int hasRiseVoltage() const;<dd>int hasFallVoltage() const;<dd>int hasRiseThresh() const;<dd>int hasFallThresh() const;<dd>int hasRiseSatcur() const;<dd>int hasFallSatcur() const;<dd>int hasCurrentSource() const;<dd>int hasTables() const;<dd>int hasAntennaSize() const;<dd>int hasAntennaMetalArea() const;<dd>int hasAntennaMetalLength() const;<dd>int hasAntennaPartialMetalArea() const;<dd>int hasAntennaPartialMetalSideArea() const;<dd>int hasAntennaPartialCutArea() const;<dd>int hasAntennaDiffArea() const;<dd>int hasAntennaModel() const;<dd>int hasTaperRule() const;<dd>int hasRiseSlewLimit() const;<dd>int hasFallSlewLimit() const;<dd>int hasNetExpr() const;<dd>int hasSupplySensitivity() const;<dd>int hasGroundSensitivity() const;<dd><dd>const char* name() const;<dd><dd>int numPorts() const;<dd></a><font color="#0000ff"><u>lefiGeometries</u></font>* port(int index) const;<dd><dd>int numForeigns() const;<dd>const char* foreignName(int index = 0) const;<dd>const char* taperRule() const;<dd>int foreignOrient(int index = 0) const; &nbsp;&#47;&#47; optional &#45; for information, see<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &#47;&#47; <a href="ch1Intro.html#1019049" title="1"><font color="DodgerBlue"><u>Orientation Codes</u></font></a><a href="ch1Intro.html#1019049" title="1"> </a><dd>const char* foreignOrientStr(int index = 0) const;<br>double foreignX(int index = 0) const;<br>double foreignY(int index = 0) const;<br>const char* LEQ() const;<br>const char* direction() const;<br>const char* use() const;<br>const char* shape() const;<br>const char* mustjoin() const;<br>double outMarginHigh() const;<br>double outMarginLow() const;<br>double outResistanceHigh() const;<br>double outResistanceLow() const;<br>double inMarginHigh() const;<br>double inMarginLow() const;<br>double power() const;<br>double leakage() const;<br>double maxload() const;<br>double maxdelay() const;<br>double capacitance() const;<br>double resistance() const;<br>double pulldownres() const;<br>double tieoffr() const;<br>double VHI() const;<br>double VLO() const;<br>double riseVoltage() const;<br>double fallVoltage() const;<br>double riseThresh() const;<br>double fallThresh() const;<br>double riseSatcur() const;<br>double fallSatcur() const;<br>double riseSlewLimit() const;<br>double fallSlewLimit() const;<br>const char* currentSource() const;<br>const char* tableHighName() const;<br>const char* tableLowName() const;<br><br>int numAntennaSize() const;<br>double antennaSize(int index) const;<br>const char* antennaSizeLayer(int index) const;<br><br>int numAntennaMetalArea() const;<br>double antennaMetalArea(int index) const;<br>const char* antennaMetalAreaLayer(int index) const;<br><br>int numAntennaMetalLength() const;<br>double antennaMetalLength(int index) const;<br>const char* antennaMetalLengthLayer(int index) const;<br><br>int numAntennaPartialMetalArea() const;<br>double antennaPartialMetalArea(int index) const;<br>const char* antennaPartialMetalAreaLayer(int index) const;<br><br>int numAntennaPartialMetalSideArea() const;<br>double antennaPartialMetalSideArea(int index) const;<br>const char* antennaPartialMetalSideAreaLayer(int index) const;<br><br>int numAntennaPartialCutArea() const;<br>double antennaPartialCutArea(int index) const;<br>const char* antennaPartialCutAreaLayer(int index) const;<br><br>int numAntennaDiffArea() const;<br>double antennaDiffArea(int index) const;<br>const char* antennaDiffAreaLayer(int index) const;<br><br>const char* netExpr() const;<br>const char* supplySensitivity() const;<br>const char* groundSensitivity() const;<br><br>int numantennaModel() const;<br><font color="#0000ff"><u>lefiPinAntennaModel</u></font>* antennaModel(int index) const;<br><br>int numProperties() const;<br>const char* propName(int index) const;<br>const char* propValue(int index) const;<br>double propNum(int index) const;<br>const char propType(int index) const;<br>int propIsNumber(int index) const;<br>int propIsString(int index) const; };</font>
      </dl>
      <h3><a name="lefiPinAntennaModel"></a><a name="1057604">lefiPinAntennaModel</a></h3>
      <p><a name="1057605">Retrieves antenna model information from Macro Pin statement of the LEF file.</a></p>
      <p><a name="1057614">For syntax information about the Macro Pin statement, see </a><a href="../lefdefref/LEFSyntax.html#MacroPinStatement" target="external_window"><font color="#0000ff"><u>&#34;Macro Pin Statement&#34;</u></font></a> in the <br><font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1057636">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057611">class lefiAntennaModel {<dd>int hasAntennaGateArea() const;<dd>int hasAntennaMaxAreaCar() cons<dd>int hasAntennaMaxSideAreaCar() const;<dd>int hasAntennaMaxCutCar() const;<dd><dd>char* antennaOxide() const;<dd><dd>int numantennaGateArea() const;<dd>double antennaGateArea(int index) const;<dd>const char* antennaGateAreaLayer(int index) const;<dd><dd>int numAntennaMaxAreaCar() const;<dd>double antennaMaxAreaCar(int index) const;<dd>const char* antennaMaxAreaCarLayer(int index) const;<dd><dd>int numAntennaMaxSideAreaCar() conts;<dd>double antennaMaxSideAreaCar(int index) const;<dd>const char* antennaMaxSideAreaCarLayer(int index) const;<dd><dd>int numAntennaMaxCutCar() const;<dd>double antennaMaxCutCar(int index) const;<dd>const char* antennaMaxCutCarLayer(int index) const; };</a></font>
      </dl>
      <h3><a name="lefiGeometries"></a><a name="1037568">lefiGeometries</a></h3>
      <p><a name="1037569">Retrieves data from the Macro Pin statement and from the Macro Obstruction statement in the </a><font size="2" face="'Courier New'" color="#000000">MACRO</font> section of the LEF file. These statements specify the pin port and obstruction geometries for the macro.</p>
      <p><a name="1037572">For syntax information about LEF geometries, see </a><a href="../lefdefref/LEFSyntax.html#LayerGeometries" target="external_window"><font color="#0000ff"><u>&#34;Layer Geometries&#34;</u></font></a> in the<font color="#000000"><em> LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1037577">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1061377">class lefiGeometries {<dd>int    numItems() const;<dd>enum   lefiGeomEnum itemType(int index) const;<dd>struct </a><font color="#0000ff"><u>lefiGeomRect</u></font>* getRect(int index) const;<dd>struct <font color="#0000ff"><u>lefiGeomRectIter</u></font>* getRectIter(int index) const;<dd>struct <font color="#0000ff"><u>lefiGeomPath</u></font>* getPath(int index) const;<dd>struct <font color="#0000ff"><u>lefiGeomPathIter</u></font>* getPathIter(int index) const;<dd>int    hasLayerExceptPgNet(int index) const;<dd>char*  getLayer(int index) const;<dd>double getLayerMinSpacing(int index) const;<dd>double getLayerRuleWidth(int index) const;<dd>double getWidth(int index) const;<dd>struct <font color="#0000ff"><u>lefiGeomPolygon</u></font>* getPolygon(int index) const;<dd>struct <font color="#0000ff"><u>lefiGeomPolygonIter</u></font>* getPolygonIter(int index) const;<dd>char*  getClass(int index) const;<dd>struct <font color="#0000ff"><u>lefiGeomVia</u></font>* getVia(int index) const;<dd>struct <font color="#0000ff"><u>lefiGeomViaIter</u></font>* getViaIter(int index) const;<dd><dd>int colorMask;<dd>};</font>
      </dl>
      <h3><a name="lefiGeomEnum"></a><a name="1037689">lefiGeomEnum</a></h3>
      <p><a name="1037690">Returns the type of geometry of a macro.</a></p>
      <h4><a name="1037691">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037692">enum lefiGeomEnum {<dd>lefiGeomunknown = 0,<dd>lefiGeomLayerE,<dd>lefiGeomLayerMinSpacingE,<dd>lefiGeomLayerRuleWidthE,<dd>lefiGeomWidthE,<dd>lefiGeomPathE,<dd>lefiGeomPathIterE,<dd>lefiGeomRectE,<dd>lefiGeomRectIterE,<dd>lefiGeomPolygonE,<dd>lefiGeomPolygonIterE,<dd>lefiGeomViaE,<dd>lefiGeomViaIterE,<dd>lefiGeomClassE,<dd>lefiGeomEnd };</a></font>
      </dl>
      <h3><a name="lefiGeomRect"></a><a name="1037694">lefiGeomRect</a></h3>
      <p><a name="1037695">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">RECT</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037696">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037697">struct lefiGeomRect {<dd>double </a><font color="#000000"><em>xl</em></font>;<dd>double <font color="#000000"><em>yl</em></font>;<dd>double <font color="#000000"><em>xh</em></font>;<dd>double <font color="#000000"><em>yh</em></font>; <dd>int <font size="2" face="'Courier New'" color="#000000"><em>colorMask</em></font>; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;specify color mask number for the GeomRect<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;structure.</font>
      </dl>
      <h3><a name="lefiGeomRectIter"></a><a name="1037705">lefiGeomRectIter</a></h3>
      <p><a name="1037706">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">RECT</font> <font size="2" face="'Courier New'" color="#000000">ITERATE</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037707">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037708">struct lefiGeomRectIter {<dd>double </a><font color="#000000"><em>xl</em></font>;<dd>double <font color="#000000"><em>yl</em></font>;<dd>double <font color="#000000"><em>xh</em></font>;<dd>double <font color="#000000"><em>yh</em></font>;<dd>double <font color="#000000"><em>xStart</em></font>;<dd>double <font color="#000000"><em>yStart</em></font>;<dd>double <font color="#000000"><em>xStep</em></font>;<dd>double <font color="#000000"><em>yStep</em></font>;<dd>int <font size="2" face="'Courier New'" color="#000000"><em>colorMask</em></font>;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;specify color mask number for the GeomRectIter<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;structure.</font>
      </dl>
      <p><font color="#000000"><strong>Note: </strong></font><a name="1058395">For the following step pattern:</a></p>
      <blockquote>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"></font>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058401">DO </a><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font> BY <font size="2" face="'Courier New'" color="#000000"><em>numY</em></font> STEP <font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font> <font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font> </font>
      </blockquote>
      <p><a name="1058402">The values are mapped to the structure in the following way:</a></p>
      <p align="left"><a name="1058404">&nbsp;</a></p>
      <table summary="" border="1" cellpadding="5" cellspacing="0" width="648">
        <caption>
        <tr>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="182">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058407">Step Pattern Value</a></strong></font>
            </p>
          </td>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="466">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058409">Maps to Structure Value</a></strong></font>
            </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058411"><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058413"><font size="2" face="'Courier New'" color="#000000"><em>xStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058415"><font size="2" face="'Courier New'" color="#000000"><em>numY</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058417"><font size="2" face="'Courier New'" color="#000000"><em>yStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058431"><font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058433"><font size="2" face="'Courier New'" color="#000000"><em>xStep</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058427"><font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058429"><font size="2" face="'Courier New'" color="#000000"><em>yStep</em></font></a> </p>
          </td>
        </tr>
      </table>
      <h3><a name="lefiGeomPath"></a><a name="1037711">lefiGeomPath</a></h3>
      <p><a name="1037712">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">PATH</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037713">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037714">struct lefiGeomPath {<dd>int </a><font size="2" face="'Courier New'" color="#000000"><em>numPoints</em></font>;<dd>double* <font size="2" face="'Courier New'" color="#000000"><em>x</em></font>;<dd>double* <font size="2" face="'Courier New'" color="#000000"><em>y</em></font>;<dd>int <font size="2" face="'Courier New'" color="#000000"><em>colorMask</em></font>; };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;specify color mask number for the GeomPath<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;structure.</font>
      </dl>
      <h3><a name="lefiGeomPathIter"></a><a name="1037717">lefiGeomPathIter</a></h3>
      <p><a name="1037718">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">PATH</font> <font size="2" face="'Courier New'" color="#000000">ITERATE</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037719">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1060896">struct lefiGeomPathIter {<dd>int </a><font size="2" face="'Courier New'" color="#000000"><em>numPoints</em></font>;<dd>double* <font color="#000000"><em>x</em></font>;<dd>double* <font color="#000000"><em>y</em></font>;<dd>double  <font color="#000000"><em>xStart</em></font>;<dd>double  <font color="#000000"><em>yStart</em></font>;<dd>double  <font color="#000000"><em>xStep</em></font>;<dd>double  <font color="#000000"><em>yStep</em></font>;<dd>int <font size="2" face="'Courier New'" color="#000000"><em>colorMask</em></font>; };&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;specify color mask number for the GeomPathIter<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;structure.</font>
      </dl>
      <p><font color="#000000"><strong>Note: </strong></font><a name="1058438">For the following step pattern:</a></p>
      <blockquote>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"></font>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058439">DO </a><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font> BY <font size="2" face="'Courier New'" color="#000000"><em>numY</em></font> STEP <font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font> <font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font> </font>
      </blockquote>
      <p><a name="1058440">The values are mapped to the structure in the following way:</a></p>
      <p align="left"><a name="1058462">&nbsp;</a></p>
      <table summary="" border="1" cellpadding="5" cellspacing="0" width="648">
        <caption>
        <tr>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="182">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058443">Step Pattern Value</a></strong></font>
            </p>
          </td>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="466">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058445">Maps to Structure Value</a></strong></font>
            </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058447"><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058449"><font size="2" face="'Courier New'" color="#000000"><em>xStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058451"><font size="2" face="'Courier New'" color="#000000"><em>numY</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058453"><font size="2" face="'Courier New'" color="#000000"><em>yStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058455"><font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058457"><font size="2" face="'Courier New'" color="#000000"><em>xStep</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058459"><font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058461"><font size="2" face="'Courier New'" color="#000000"><em>yStep</em></font></a> </p>
          </td>
        </tr>
      </table>
      <h3><a name="lefiGeomPolygon"></a><a name="1037728">lefiGeomPolygon</a></h3>
      <p><a name="1037729">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">POLYGON</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037730">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1062146">struct lefiGeomPolygon {<dd>int </a><font size="2" face="'Courier New'" color="#000000"><em>numPoints</em></font>;<dd>double* <font color="#000000"><em>x</em></font>;<dd>double* <font color="#000000"><em>y</em></font>;<dd>int <font size="2" face="'Courier New'" color="#000000"><em>colorMask</em></font>; };&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;specify color mask number for the GeomPolygon<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;structure.</font>
      </dl>
      <h3><a name="lefiGeomPolygonIter"></a><a name="1037734">lefiGeomPolygonIter</a></h3>
      <p><a name="1037735">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">POLYGON</font> <font size="2" face="'Courier New'" color="#000000">ITERATE</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037736">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1061052">struct lefiGeomPolygonIter {<dd>int </a><font size="2" face="'Courier New'" color="#000000"><em>numPoints</em></font>;<dd>double* <font color="#000000"><em>x</em></font>;<dd>double* <font color="#000000"><em>y</em></font>;<dd>double  <font color="#000000"><em>xStart</em></font>;<dd>double  <font color="#000000"><em>yStart</em></font>;<dd>double  <font color="#000000"><em>xStep</em></font>;<dd>double  <font color="#000000"><em>yStep</em></font>;<dd>int <font size="2" face="'Courier New'" color="#000000"><em>colorMask</em></font>; };&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;specify color mask number for the GeomPolygonIter<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;structure.</font>
      </dl>
      <p><font color="#000000"><strong>Note: </strong></font><a name="1058473">For the following step pattern:</a></p>
      <blockquote>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"></font>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058474">DO </a><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font> BY <font size="2" face="'Courier New'" color="#000000"><em>numY</em></font> STEP <font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font> <font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font> </font>
      </blockquote>
      <p><a name="1058475">The values are mapped to the structure in the following way:</a></p>
      <p align="left"><a name="1058497">&nbsp;</a></p>
      <table summary="" border="1" cellpadding="5" cellspacing="0" width="648">
        <caption>
        <tr>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="182">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058478">Step Pattern Value</a></strong></font>
            </p>
          </td>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="466">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058480">Maps to Structure Value</a></strong></font>
            </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058482"><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058484"><font size="2" face="'Courier New'" color="#000000"><em>xStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058486"><font size="2" face="'Courier New'" color="#000000"><em>numY</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058488"><font size="2" face="'Courier New'" color="#000000"><em>yStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058490"><font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058492"><font size="2" face="'Courier New'" color="#000000"><em>xStep</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058494"><font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058496"><font size="2" face="'Courier New'" color="#000000"><em>yStep</em></font></a> </p>
          </td>
        </tr>
      </table>
      <h3><a name="lefiGeomVia"></a><a name="1037740">lefiGeomVia</a></h3>
      <p><a name="1037741">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">VIA</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037742">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1061119">struct lefiGeomVia {<dd>char*  </a><font color="#000000"><em>name</em></font>;<dd>double <font color="#000000"><em>x</em></font>;<dd>double <font color="#000000"><em>y</em></font>;<dd>int <font size="2" face="'Courier New'" color="#000000"><em>topMaskNum</em></font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;define top mask number for the GeomVia structure.<dd>int <font size="2" face="'Courier New'" color="#000000"><em>cutMaskNum</em></font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;define cut mask number for the GeomVia structure.<dd>int <font size="2" face="'Courier New'" color="#000000"><em>bottomMaskNum</em></font>;};&nbsp;&nbsp;&#47;&#47;define bottom mask number for the GeomVia structure.</font>
      </dl>
      <h3><a name="lefiGeomViaIter"></a><a name="1037746">lefiGeomViaIter</a></h3>
      <p><a name="1037747">Returns data from the </a><font size="2" face="'Courier New'" color="#000000">VIA</font> <font size="2" face="'Courier New'" color="#000000">ITERATE</font> statement in the <font size="2" face="'Courier New'" color="#000000">MACRO</font> section.</p>
      <h4><a name="1037748">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1061337">struct lefiGeomViaIter {<dd>char*  </a><font color="#000000"><em>name</em></font>;<dd>double <font color="#000000"><em>x</em></font>;<dd>double <font color="#000000"><em>y</em></font>;<dd>double <font color="#000000"><em>xStart</em></font>;<dd>double <font color="#000000"><em>yStart</em></font>;<dd>double <font color="#000000"><em>xStep</em></font>;<dd>double <font color="#000000"><em>yStep</em></font>;<dd>int <font size="2" face="'Courier New'" color="#000000"><em>topMaskNum</em></font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;define top mask number for the GeomViaIter structure.<dd>int <font size="2" face="'Courier New'" color="#000000"><em>cutMaskNum</em></font>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;define cut mask number for the GeomViaIter structure.<dd>int <font size="2" face="'Courier New'" color="#000000"><em>bottomMaskNum</em></font>;};&nbsp;&nbsp;&#47;&#47;define bottom mask number for the GeomViaIter<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47;structure.</font>
      </dl>
      <p><font color="#000000"><strong>Note: </strong></font><a name="1061338">For the following step pattern:</a></p>
      <blockquote>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"></font>
        <font size="2" face="&quot;Courier New&quot;" color="#000000"><a name="1058505">DO </a><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font> BY <font size="2" face="'Courier New'" color="#000000"><em>numY</em></font> STEP <font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font> <font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font> </font>
      </blockquote>
      <p><a name="1058506">The values are mapped to the structure in the following way:</a></p>
      <p align="left"><a name="1058528">&nbsp;</a></p>
      <table summary="" border="1" cellpadding="5" cellspacing="0" width="648">
        <caption>
        <tr>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="182">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058509">Step Pattern Value</a></strong></font>
            </p>
          </td>
          <td bgcolor="#CCCCCC" cellpadding="4" border="2" bordercolor="#000000" valign="middle" width="466">
            <p>
              <font face="Verdana, Arial, Helvetica, sans-serif" color="#003366"><strong><a name="1058511">Maps to Structure Value</a></strong></font>
            </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058513"><font size="2" face="'Courier New'" color="#000000"><em>numX</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058515"><font size="2" face="'Courier New'" color="#000000"><em>xStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058517"><font size="2" face="'Courier New'" color="#000000"><em>numY</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058519"><font size="2" face="'Courier New'" color="#000000"><em>yStart</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" valign="top">
            <p><a name="1058521"><font size="2" face="'Courier New'" color="#000000"><em>spaceX</em></font></a> </p>
          </td>
          <td cellpadding="4" valign="top">
            <p><a name="1058523"><font size="2" face="'Courier New'" color="#000000"><em>xStep</em></font></a> </p>
          </td>
        </tr>
        <tr>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058525"><font size="2" face="'Courier New'" color="#000000"><em>spaceY</em></font></a> </p>
          </td>
          <td cellpadding="4" border="1" bordercolor="#000000" valign="top">
            <p><a name="1058527"><font size="2" face="'Courier New'" color="#000000"><em>yStep</em></font></a> </p>
          </td>
        </tr>
      </table>
      <h3><a name="1037795">Macro Pin Examples</a></h3>
      <p><a name="1037796">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrPinCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiPin</font>. This example only shows how to retrieve part of the data from the <font size="2" face="'Courier New'" color="#000000">lefiPin</font> class.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037797">int macroPinCB (lefrCallbackType_e type,<dd>                lefiPin* pinInfo,<dd>                lefiUserData userData) {<dd><dd>    lefiGeometries*       geometry;<dd>    int                   numPorts;<dd>    int                   numItems;<dd>    int                   i, j;<dd>    lefiGeomPath*         path;<dd>    lefiGeomPathIter*     pathIter;<dd>    lefiGeomRect*         rect;<dd>    lefiGeomRectIter*     rectIter;<dd>    lefiGeomPolygon*      polygon;<dd>    lefiGeomPolygonIter*  polygonIter;<dd>    lefiGeomVia*          via;<dd>    lefiGeomViaIter*      viaIter;<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037799">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrPinCbkType) {<dd>        printf(&#34;Type is not lefrPinCbkType, terminate parsing.\n&#34;);<dd>        return 1;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037800">    printf(&#34;PIN %s\n&#34;, pin&#45;&#62;name());<dd><dd>    if (pin&#45;&#62;hasForeign()) {<dd>        if (pin&#45;&#62;hasForeignOrient())<dd>            printf(&#34;  FOREIGN %s STRUCTURE ( %g %g ) %d\n&#34;, <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pin&#45;&#62;foreignName(), pin&#45;&#62;foreignX(), <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pin&#45;&#62;foreignY(), pin&#45;&#62;foreignOrient());<dd>        else if (pin&#45;&#62;hasForeignPoint())<dd>            printf(&#34;  FOREIGN %s STRUCTURE ( %g %g )\n&#34;,<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pin&#45;&#62;foreignName(), pin&#45;&#62;foreignX(), <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pin&#45;&#62;foreignY());<dd>        else<dd>            printf(&#34;  FOREIGN %s\n&#34;, pin&#45;&#62;foreignName());<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037801">    if (pin&#45;&#62;hasLEQ())<dd>        printf(&#34;  LEQ %s\n&#34;, pin&#45;&#62;LEQ());<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037802">    if (pin&#45;&#62;hasAntennaSize()) {<dd>        for (i = 0; i &#60; pin&#45;&#62;numAntennaSize(); i++) {<dd>            printf(&#34;  ANTENNASIZE %g &#34;, pin&#45;&#62;antennaSize(i));<dd>           if (pin&#45;&#62;antennaSizeLayer(i))<dd>               printf(&#34;LAYER %s &#34;, pin&#45;&#62;antennaSizeLayer(i));<dd>           printf(&#34;\n&#34;);<dd>        }<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1037803">    numPorts = pin&#45;&#62;numPorts();<dd>    for (i = 0; i &#60; numPorts; i++) {<dd>        printf(&#34;  PORT\n&#34;);<dd>        geometry = pin&#45;&#62;port(i);<dd>        &#47;&#47; A complete example can be found .<dd>        numItems = geometry&#45;&#62;numItems();<dd>        for (j = 0; j &#60; numItems; j++) {<dd>            switch (geometry&#45;&#62;itemType(j)) {<dd>                case lefiGeomClassE:<dd>                     printf(&#34;   CLASS %s\n&#34;, geometry&#45;&#62;getClass(j));<dd>                     break;<dd>                case lefiGeomLayerE:<dd>                     printf(&#34;   LAYER %s\n&#34;, geometry&#45;&#62;getLayer(j));<dd>                     break;<dd>                case lefiGeomWidthE:<dd>                     printf(&#34;   WIDTH %g\n&#34;, geometry&#45;&#62;getWidth(j));<dd>                     break;<dd>                case lefiGeomPathE:<dd>                     ...<dd>                     break;<dd>                case lefiGeomPathIterE:<dd>                     ...<dd>                     break;<dd>                case lefiGeomRectE:<dd>                     rect = geometry&#45;&#62;getRect(j);<dd>                     printf(&#34;   RECT ( %g %g ) ( %g %g )\n&#34;, rect&#45;&#62;xl,<dd>                            rect&#45;&#62;yl, rect&#45;&#62;xh, rect&#45;&#62;yh);<dd>                     break;<dd>                case lefiGeomRectIterE:<dd>                     ...<dd>                     break;<dd>                case lefiGeomPolygonE:<dd>                     ...<dd>                     break;<dd>                case lefiGeomPolygonIterE:<dd>                     ...<dd>                     break;<dd>                case lefiGeomViaE:<dd>                     ...<dd>                     break;<dd>                case lefiGeomViaIterE:<dd>                     ...<dd>                     break;<dd>            }<dd>        }<dd>    }<dd>    return 0; }</a></font>
      </dl>
      <h2><a name="1037937">Maximum Via Stack Class</a></h2>
      <p><a name="1057818">The LEF </a><font size="2" face="'Courier New'" color="#000000">MAXSTACKVIA</font> routines include the following LEF class:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a name="1057823"> </a><a href="#lefiMaxStackVia" title="4"><font color="Blue"><u>lefiMaxStackVia</u></font></a><a href="#lefiMaxStackVia" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiMaxStackVia"></a><a name="1057808">lefiMaxStackVia</a></h3>
      <p><a name="1057809">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">MAXVIASTACK</font> statement in the LEF file. </p>
      <p><a name="1057811">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">MAXVIASTACK</font> statement, see <a href="../lefdefref/LEFSyntax.html#MaximumViaStack" target="external_window"><font color="#0000ff"><u>&#34;Maximum Via Stack&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1057812">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057813">class lefiMaxStackVia {<dd>int maxStackVia() const;<dd>int hasMaxStackViaRange() const;<dd>const char* maxStackViaBottomLayer() const;<dd>const char* maxStackViaTopLayer() const; }</a></font>
      </dl>
      <h2><a name="1057802">Miscellaneous Class</a></h2>
      <p><a name="1037938">Miscellaneous routines include the following LEF class:</a></p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiUserData" title="4" name="1057749"><font color="Blue"><u>lefiUserData</u></font></a><a href="#lefiUserData" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiUserData"></a><a name="1037967">lefiUserData</a></h3>
      <p><a name="1057669">The user data can be set or changed at any time with the </a><font size="2" face="'Courier New'" color="#000000">lefrSetUserData</font> and <font size="2" face="'Courier New'" color="#000000">lefrGetUserData</font> calls. Every callback returns the user data as the third argument.</p>
      <h4><a name="1057670">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057671">lefiUserData lefrGetUserData()</a></font>
      </dl>
      <h2><a name="1038008">Nondefault Rule Class</a></h2>
      <p><a name="lefiNonDefault"></a><a name="1038015">The LEF </a><font size="2" face="'Courier New'" color="#000000">NONDEFAULT</font> <font size="2" face="'Courier New'" color="#000000">RULE</font> routines include the following LEF class:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiNonDefault" title="4" name="1038019"><font color="Blue"><u>lefiNonDefault</u></font></a><a href="#lefiNonDefault" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiNonDefault"></a><a name="1038047">lefiNonDefault </a></h3>
      <p><a name="1038048">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">NONDEFAULTRULE</font> statement in the LEF file.</p>
      <p><a name="1038051">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">NONDEFAULTRULE</font> statement, see <a href="../lefdefref/LEFSyntax.html#NondefaultRule" target="external_window"><font color="#0000ff"><u>&#34;Nondefault Rule&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1038053">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038054">class lefiNonDefault {<dd>const char* name() const;<dd>int hardSpacing() const;<dd>int numProps() const;<dd>const char* propName(int index) const;<dd>const char* propValue(int index) const;<dd>double propNumber(int index) const;<dd>const char propType(int index) const; <dd>int propIsNumber(int index) const;<dd>int propIsString(int index) const;</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058114">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numLayers() const;<dd>const char* layerName(int index) const;<dd>int hasLayerWidth(int index) const;<dd>double layerWidth(int index) const;<dd>int hasLayerSpacing(int index) const;<dd>double layerSpacing(int index) const;<dd>int hasLayerWireExtension(int index) const;<dd>double layerWireExtension(int index) const;<dd>int hasLayerDiagWidth(int index) const;<dd>double layerDiagWidth(int index) const;<dd><dd>int numVias() const;<dd></a><font color="#0000ff"><u>lefiVia</u></font>* viaRule(int index) const;</font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038058">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numSpacingRules() const;<dd></a><font color="#0000ff"><u>lefiSpacing</u></font>* spacingRule(int index) const;<dd><dd>int numUseVia() const;<dd>const char* viaName(int index) const;<dd>int numUseViaRule() const;<dd>const char* viaRuleName(int index) const;<dd>int numMinCuts() const;<dd>const char* cutLayerName(int index) const;<dd>int numCuts(int index) const; };</font>
      </dl>
      <h3><a name="1038111">Nondefault Rule Examples</a></h3>
      <p><a name="1038112">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrNonDefaultCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiNonDefault</font>. This example only shows how to retrieve part of the data from the <font size="2" face="'Courier New'" color="#000000">lefiNonDefault</font> class. For examples of how to retrieve via and spacing data, see the Via Routines and Same&#45;Net Spacing Routines sections. </p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038113">int nonDefaultCB (lefrCallbackType_e type,<dd>                  lefiNonDefault* nonDefInfo,<dd>                  lefiUserData userData) {<dd>    int          i;<dd>    lefiVia*     via;<dd>    lefiSpacing* spacing;<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038114">    &nbsp;&#47;&#47; Check if the type is correct<dd>    if (type != lefrNonDefaultCbkType) {<dd>        printf(&#34;Type is not lefrNonDefaultCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1; }<dd><dd>&#47;&#47; Print out nondefaultrule data<dd>    printf(&#34;NONDEFAULTRULE %s\n&#34;, def&#45;&#62;name());<dd>    for (i = 0; i &#60; def&#45;&#62;numLayers(); i++) {<dd>        printf(&#34;  LAYER %s\n&#34;, def&#45;&#62;layerName(i));<dd>        if (def&#45;&#62;hasLayerWidth(i))<dd>            printf(&#34;    WIDTH %g\n&#34;, def&#45;&#62;layerWidth(i));<dd>        if (def&#45;&#62;hasLayerSpacing(i))<dd>            printf(&#34;    SPACING %g\n&#34;, def&#45;&#62;layerSpacing(i));}<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038115">    &nbsp;&#47;&#47; handle via in nondefaultrule<dd>    for (i = 0; i &#60; def&#45;&#62;numVias(); i++) {<dd>        via = def&#45;&#62;viaRule(i);<dd><dd>    &#47;&#47; handle spacing in nondefaultrule<dd>    for (i = 0; i &#60; def&#45;&#62;numSpacingRules(); i++) {<dd>        spacing = def&#45;&#62;spacingRule(i);}<dd><dd>  return 0;}</a></font>
      </dl>
      <h2><a name="1038123">Property Definition Classes</a></h2>
      <p><a name="lefiNonDefault"></a><a name="1038129">The LEF </a><font size="2" face="'Courier New'" color="#000000">PROPERTYDEFINITIONS</font> routines include the following classes:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiProp" title="4" name="1038133"><font color="Blue"><u>lefiProp</u></font></a><a href="#lefiProp" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiPropType" title="4" name="1053120"><font color="Blue"><u>lefiPropType</u></font></a><a href="#lefiPropType" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiProp"></a><a name="1037566">lefiProp</a></h3>
      <p><a name="1033070">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">PROPERTYDEFINITIONS</font> statement in the LEF file. The <font size="2" face="'Courier New'" color="#000000">PROPERTYDEFINITIONS</font> statement lists all properties used in the LEF file. You must define properties before you refer to them in other routines in the LEF file.</p>
      <p><a name="1038160">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">PROPERTYDEFINITIONS</font> statement, see <font color="#0000ff"><u>&#34;Property </u></font><a href="../lefdefref/LEFSyntax.html#PropertyDefinitions" target="external_window"><font color="#0000ff"><u>Definitions&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1018620">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1034481">class lefiProp {<dd>const char* string() const;<dd>const char* propType() const;<dd>const char* propName() const;<dd>char  dataType() const;<dd>int hasNumber() const;<dd>int hasRange() const;<dd>int hasString() const;<dd>int hasNameMapString() const;<dd>double number() const;<dd>double left() const;<dd>double right() const;};</a></font>
      </dl>
      <h3><a name="lefiPropType"></a><a name="1057835">lefiPropType</a></h3>
      <p><a name="1057836">Retrieves the data type from the LEF </a><font size="2" face="'Courier New'" color="#000000">PROPERTYDEFINITIONs</font> statement in the LEF file, if the property is of type <font size="2" face="'Courier New'" color="#000000">REAL</font> or <font size="2" face="'Courier New'" color="#000000">INTEGER</font>.    </p>
      <p><a name="1057912">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">PROPERTYDEFINITIONS</font> statement, see <font color="#0000ff"><u>&#34;Property </u></font><a href="../lefdefref/LEFSyntax.html#PropertyDefinitions" target="external_window"><font color="#0000ff"><u>Definitions&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1057837">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057838">class lefiPropType {<dd>const char propType(char* name) const; };</a></font>
      </dl>
      <h3><a name="1053125">Property Definition Examples</a></h3>
      <p><a name="1038166">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrPropBeginCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">void *</font>. This callback routine marks the beginning of the Property Definition section.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038167">int propDefBeginCB (lefrCallbackType_e type,<dd>                    void* dummy,<dd>                    lefiUserData userData) {<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038168">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrPropBeginCbkType) {<dd>        printf(&#34;Type is not lefrPropBeginCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038169">    printf(&#34;PROPERTYDEFINITIONS\n&#34;);<dd>    return 0;}<dd></a></font>
      </dl>
      <p><a name="1038170">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrPropCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiProp</font>. This callback routine will be called for each defined property definition.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038171">int propDefCB (lefrCallbackType_e type,<dd>               lefiProp* propInfo,<dd>               lefiUserData userData) {<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038172">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrPropCbkType) {<dd>        printf(&#34;Type is not lefrPropCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038173">    &#47;&#47; Check the object type of the property definition<dd>    if (strcmp(propInfo&#45;&#62;propType(), &#34;library&#34;) == 0)<dd>        printf(&#34;LIBRARY %s &#34;, propInfo&#45;&#62;propName());<dd>    else if (strcmp(propInfo&#45;&#62;propType(), &#34;pin&#34;) == 0)<dd>        printf(&#34;PIN %s &#34;, propInfo&#45;&#62;propName());<dd>    else if (strcmp(propInfo&#45;&#62;propType(), &#34;macro&#34;) == 0)<dd>        printf(&#34;MACRO %s &#34;, propInfo&#45;&#62;propName());<dd>    else if (strcmp(propInfo&#45;&#62;propType(), &#34;via&#34;) == 0)<dd>        printf(&#34;VIA %s &#34;, propInfo&#45;&#62;propName());<dd>    else if (strcmp(propInfo&#45;&#62;propType(), &#34;viarule&#34;) == 0)<dd>        printf(&#34;VIARULE %s &#34;, propInfo&#45;&#62;propName());<dd>    else if (strcmp(propInfo&#45;&#62;propType(), &#34;layer&#34;) == 0)<dd>        printf(&#34;LAYER %s &#34;, propInfo&#45;&#62;propName());<dd>    else if (strcmp(propInfo&#45;&#62;propType(), &#34;nondefaultrule&#34;) == 0<dd>        printf(&#34;NONDEFAULTRULE %s &#34;, propInfo&#45;&#62;propName());<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1039586">    &#47;&#47; Check the property type<dd>    if (propInfo&#45;&#62;dataType() == 'I')<dd>        printf(&#34;INTEGER &#34;);<dd>    if (propInfo&#45;&#62;dataType() == 'R')<dd>        printf(&#34;REAL &#34;);<dd>    if (propInfo&#45;&#62;dataType() == 'S')<dd>        printf(&#34;STRING &#34;);<dd>    if (propInfo&#45;&#62;dataType() == 'Q')<dd>        printf(&#34;STRING &#34;);<dd>    if (propInfo&#45;&#62;hasRange()) {<dd>        printf(&#34;RANGE %g %g &#34;, propInfo&#45;&#62;left(), propInfo&#45;<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#62;right());<dd>    }<dd>    if (propInfo&#45;&#62;hasNumber())<dd>        printf(&#34;%g &#34;, propInfo&#45;&#62;number());<dd>    if (propInfo&#45;&#62;hasString())<dd>        printf(&#34;&#39;%s&#39; &#34;, propInfo&#45;&#62;string());<dd><dd>    printf(&#34;\n&#34;);<dd><dd>    return 0;}<dd></a></font>
      </dl>
      <p><a name="1039587">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrPropEndCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">void *</font>. This callback routine marks the end of the Property Definition section.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038176">int propDefEndCB (lefrCallbackType_e type,<dd>                  void* dummy,<dd>                  lefiUserData userData) {<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038177">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrPropEndCbkType) {<dd>        printf(&#34;Type is not lefrPropEndCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;}<dd><dd>    printf(&#34;END PROPERTYDEFINITIONS\n&#34;);<dd>    return 0;}</a></font>
      </dl>
      <h2><a name="1038189">Same&#45;Net Spacing Class</a></h2>
      <p><a name="1038190">The LEF </a><font size="2" face="'Courier New'" color="#000000">SPACING</font> routines include the following LEF class:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiSpacing" title="4" name="1038194"><font color="Blue"><u>lefiSpacing</u></font></a><a href="#lefiSpacing" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiSpacing"></a><a name="1038211">lefiSpacing</a></h3>
      <p><a name="1038212">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">SPACING</font> statement in the LEF file. </p>
      <h4><a name="1038217">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038218">class lefiSpacing {<dd>int hasStack() const;<dd>const char* name1() const;<dd>const char* name2() const;<dd>double distance() const;};</a></font>
      </dl>
      <h3><a name="1038246">Same&#45;Net Spacing Examples</a></h3>
      <p><a name="1038247">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrSpacingCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiSpacing</font>. This callback routine is called for each defined spacing between callback routines with the types <font size="2" face="'Courier New'" color="#000000">lefrSpacingBeginCbkType</font> and <font size="2" face="'Courier New'" color="#000000">lefrSpacingEndCbkType</font>.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038248">int spacingCB (lefrCallbackType_e type,<dd>               lefiSpacing* spacingInfo,<dd>               lefiUserData userData) {<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038249">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrSpacingCbkType) {<dd>        printf(&#34;Type is not lefrSpacingCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038250">    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&#34;SAMENET %s %s %g &#34;, spacingInfo&#45;&#62;name1(),<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spacingInfo&#45;&#62;name2(), spacingInfo&#45;&#62;distance());<dd>    if (spacingInfo&#45;&#62;hasStack())<dd>        printf(&#34;STACK &#34;);<dd>    printf(&#34;\n&#34;);<dd><dd>    return 0; }</a></font>
      </dl>
      <h2><a name="1038259">Site Classes</a></h2>
      <p><a name="1038260">The LEF </a><font size="2" face="'Courier New'" color="#000000">SITE</font> routines include the following LEF class:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiSite" title="4" name="1038264"><font color="Blue"><u>lefiSite</u></font></a><a href="#lefiSite" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiSitePattern" title="4" name="1058103"><font color="#0000ff"><u>lefiSitePattern</u></font></a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiSite"></a><a name="1038163">lefiSite</a></h3>
      <p><a name="1033086">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">SITE</font> statement of the LEF file. </p>
      <p><a name="1033090">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">SITE</font> statement, see <a href="../lefdefref/LEFSyntax.html#Site" target="external_window"><font color="#0000ff"><u>&#34;Site&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1014306">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1014307">class lefiSite {<dd>const char* name() const;<dd>int hasClass() const;<dd>const char* siteClass() const;<dd>double sizeX() const;<dd>double sizeY() const;<dd>int hasSize() const;<dd>int hasXSymmetry() const;<dd>int hasYSymmetry() const;<dd>int has90Symmetry() const;<dd>int hasRowPattern() const;<dd>int numSites() const;<dd>char* siteName(int index) const;<dd>int siteOrient(int index) const;<dd>char* siteOrientStr(int index) const; };</a></font>
      </dl>
      <h3><a name="lefiSitePattern"></a><a name="1058076">lefiSitePattern</a></h3>
      <p><a name="1058096">Retrieves site pattern information from the </a><font size="2" face="'Courier New'" color="#000000">SITE</font> statement of the LEF file. </p>
      <p><a name="1058098">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">SITE</font> statement, see <a href="../lefdefref/LEFSyntax.html#Site" target="external_window"><font color="#0000ff"><u>&#34;Site&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1058081">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058082">lefiSitePattern {<dd>const char* name() const;<dd>int orient() const;<dd>const char* orientStr() const;<dd>double x() const;<dd>double y() const;<dd>int hasStepPattern () const;<dd>double xStart() const;<dd>double yStart() const;<dd>double xStep() const;<dd>double yStep() const; };</a></font>
      </dl>
      <h3><a name="1038917">Site Examples</a></h3>
      <p><a name="1038280">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrSiteCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiSite</font>.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038281">int siteCB (lefrCallbackType_e type,<dd>            lefiSite* siteInfo,<dd>            lefiUserData userData) {<dd>    int hasPrtSym = 0;<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038282">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrSiteCbkType) {<dd>        printf(&#34;Type is not lefrSiteCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;<dd>    }<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038283">    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&#34;SITE %s\n&#34;, siteInfo&#45;&#62;name());<dd>    if (siteInfo&#45;&#62;hasClass())<dd>        printf(&#34;  CLASS %s\n&#34;, siteInfo&#45;&#62;siteClass());<dd>    if (siteInfo&#45;&#62;hasXSymmetry()) {<dd>        printf(&#34;  SYMMETRY X &#34;);<dd>        hasPrtSym = 1; &#47;&#47; set the flag that the keyword SYMMETRY<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; has written<dd>    }<dd>    if (siteInfo&#45;&#62;hasYSymmetry()) {<dd>        if (hasPrtSym)<dd>            printf(&#34;Y &#34;);<dd>        else {         &#47;&#47; keyword SYMMETRY has not been written yet<dd>            printf(&#34;  SYMMETRY Y &#34;);<dd>            hasPrtSym = 1;<dd>        }<dd>    }<dd>    if (siteInfo&#45;&#62;has90Symmetry()) {<dd>        if (hasPrtSym)<dd>            printf(&#34;R90 &#34;);<dd>        else {<dd>            printf(&#34;  SYMMETRY R90 &#34;);<dd>            hasPrtSym = 1;<dd>        }<dd>    }<dd>    if (hasPrtSym)<dd>        printf(&#34;\n&#34;);<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1057338">    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (siteInfo&#45;&#62;hasSize())<dd>        printf(&#34;  SIZE %g BY %g\n&#34;, siteInfo&#45;&#62;sizeX(),<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;siteInfo&#45;&#62;sizeY());<dd>    printf(&#34;END %s\n&#34;, siteInfo&#45;&#62;name());<dd>    return 0;}</a></font>
      </dl>
      <h2><a name="1057340">Units Class</a></h2>
      <p><a name="1038302">The LEF </a><font size="2" face="'Courier New'" color="#000000">UNITS</font> routines include the following LEF class:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1038312" title="4" name="1038306"><font color="Blue"><u>lefiUnits</u></font></a><a href="#1038312" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="1038312">lefiUnits</a></h3>
      <p><a name="1038326">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">UNITS</font> statement of the LEF file. This statement defines the units of measure in LEF. </p>
      <p><a name="1038313">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">UNITS</font> statement, see <a href="../lefdefref/LEFSyntax.html#Units" target="external_window"><font color="#0000ff"><u>&#34;Units&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1038318">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038319">class lefiUnits {<dd>int hasDatabase();<dd>int hasCapacitance();<dd>int hasResistance();<dd>int hasTime();<dd>int hasPower();<dd>int hasCurrent();<dd>int hasVoltage();<dd>int hasFrequency();</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038320">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const char* databaseName();<dd>double databaseNumber();<dd>double capacitance();<dd>double resistance();<dd>double time();<dd>double power();<dd>double current();<dd>double voltage();<dd>double frequency();};</a></font>
      </dl>
      <h3><a name="1038332">Units Examples</a></h3>
      <p><a name="1038333">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrUnitsCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiUnits</font>.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038334">int unitsCB (lefrCallbackType_e type,<dd>             lefiUnits* unitInfo,<dd>             lefiUserData userData) {<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038335">    &#47;&#47; Check if the type is correct<dd>    if (type != lefrUnitsCbkType) {<dd>        printf(&#34;Type is not lefrUnitsCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;}<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038336">    printf(&#34;UNITS\n&#34;);<dd>    if (unitInfo&#45;&#62;hasDatabase())<dd>        printf(&#34;  DATABASE %s %g\n&#34;, unitInfo&#45;&#62;databaseName(),<dd>                unitInfo&#45;&#62;databaseNumber());<dd>    if (unitInfo&#45;&#62;hasCapacitance())<dd>        printf(&#34;  CAPACITANCE PICOFARADS %g\n&#34;,<dd>                unitInfo&#45;&#62;capacitance());<dd>    if (unitInfo&#45;&#62;hasResistance())<dd>        printf(&#34;  RESISTANCE OHMS %g\n&#34;, unitInfo&#45;&#62;resistance());<dd>    if (unitInfo&#45;&#62;hasPower())<dd>        printf(&#34;  POWER MILLIWATTS %g\n&#34;, unitInfo&#45;&#62;power());<dd>    if (unitInfo&#45;&#62;hasCurrent())<dd>        printf(&#34;  CURRENT MILLIAMPS %g\n&#34;, unitInfo&#45;&#62;current());<dd>    if (unitInfo&#45;&#62;hasVoltage())<dd>        printf(&#34;  VOLTAGE VOLTS %g\n&#34;, unitInfo&#45;&#62;voltage());<dd>    if (unitInfo&#45;&#62;hasFrequency())<dd>        printf(&#34;  FREQUENCY MEGAHERTZ %g\n&#34;, unitInfo&#45;<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#62;frequency());<dd>    printf(&#34;END UNITS\n&#34;);<dd>    return 0;};</a></font>
      </dl>
      <h2><a name="1050128">Use Min Spacing Class</a></h2>
      <p><a name="1050143">The LEF </a><font size="2" face="'Courier New'" color="#000000">USEMINSPACING</font> routines include the following LEF class:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiUseMinSpacing" title="4" name="1050144"><font color="Blue"><u>lefiUseMinSpacing</u></font></a><a href="#lefiUseMinSpacing" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiUseMinSpacing"></a><a name="1050146">lefiUseMinSpacing</a></h3>
      <p><a name="1050137">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">USEMINSPACING</font> statement of the LEF file.</p>
      <p><a name="1053102">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">USEMINSPACING</font> statement, see <a href="../lefdefref/LEFSyntax.html#UseMinSpacing" target="external_window"><font color="#0000ff"><u>&#34;Use Min Spacing&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1050138">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1050136">class lefiUseMinSpacing { <dd>const char* name() const; <dd>int value() const;};</a></font>
      </dl>
      <h2><a name="1038345">Via Classes</a></h2>
      <p><a name="1038346">The LEF </a><font size="2" face="'Courier New'" color="#000000">VIA</font> routines include the following LEF classes:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#1038372" title="4" name="1038350"><font color="Blue"><u>lefiVia</u></font></a><a href="#1038372" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiViaLayer" title="4" name="1038354"><font color="Blue"><u>lefiViaLayer</u></font></a><a href="#lefiViaLayer" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiUnits"></a><a name="lefiVia"></a><a name="1038372">lefiVia</a></h3>
      <p><a name="1038373">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">VIA</font> section of the LEF file. </p>
      <p><a name="1038539">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">VIA</font> section, see <a href="../lefdefref/LEFSyntax.html#Via" target="external_window"><font color="#0000ff"><u>&#34;Via&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1038378">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038379">class lefiVia {<dd>int hasDefault() const ;<dd>int hasGenerated() const;<dd>int hasForeign() const ; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; optional &#45; for information, see <dd>						 	&nbsp;&nbsp;&#47;&#47; </a><a href="ch1Intro.html#1019049" title="1"><font color="DodgerBlue"><u>Orientation Codes</u></font></a><a href="ch1Intro.html#1019049" title="1"> </a> <dd>int hasForeignPnt() const ;<dd>int hasForeignOrient() const ;<dd>int hasProperties() const ;<dd>int hasResistance() const ;<dd>int hasTopOfStack() const ;</font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038380">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numLayers() const;<dd>char* layerName(int layerNum) const;<dd>int numRects(int layerNum) const;<dd>double xl(int layerNum, int rectNum) const;<dd>double yl(int layerNum, int rectNum) const;<dd>double xh(int layerNum, int rectNum) const;<dd>double yh(int layerNum, int rectNum) const;<dd>int numPolygons(int layerNum) const;<dd>struct lefiGeomPolygon getPolygon(int layerNum, int polyNum) const;<dd><dd>char* name() const ;<dd>double resistance() const ;</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1062080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numProperties() const ;<dd>char* propName(int index) const;<dd>char* propValue(int index) const;<dd>double propNumber(int index) const;<dd>char propType(int index) const:<dd>int propIsNumber(int index) const;<dd>int propIsString(int index) const;<dd>char* foreign() const;<dd>double foreignX() const;<dd>double foreignY() const;<dd>int foreignOrient() const;<dd>char* foreignOrientStr() const; <dd><dd>int hasViaRule() const;<dd>const char* viaRuleName() const;<dd>double xCutSize() const;<dd>double yCutSize() const;<dd>const char* botMetalLayer() const;<dd>const char* cutLayer() const;<dd>const char* topMetalLayer() const;<dd>double xCutSpacing() const;<dd>double yCutSpacing() const;<dd>double xBotEnc() const;<dd>double yBotEnc() const;<dd>double xTopEnc() const;<dd>double yTopEnc() const;<dd>int hasRowCol() const;<dd>int numCutRows() const;<dd>int numCutCols() const;<dd>int hasOrigin() const;<dd>double xOffset() const;<dd>double yOffset() const;<dd>int hasOffset() const;<dd>double xBotOffset() const;<dd>double yBotOffset() const;<dd>double xTopOffset() const;<dd>double yTopOffset() const;<dd>int hasCutPattern() const;<dd>const char* cutPattern() const; <dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double </a><font size="2" face="'Courier New'" color="#000000"><em>xl</em></font>, <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double <font size="2" face="'Courier New'" color="#000000"><em>yl</em></font>,<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double <font size="2" face="'Courier New'" color="#000000"><em>xh</em></font>,<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double <font size="2" face="'Courier New'" color="#000000"><em>yh</em></font>);<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefiGeometries* geom); <dd>int rectColorMask(int layerNum, <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rectNum); <dd>int polyColorMask(int layerNum, <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int rectNum); };</font>
      </dl>
      <h3><a name="lefiViaLayer"></a><a name="1039637">lefiViaLayer</a></h3>
      <p><a name="1039638">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> statement within the <font size="2" face="'Courier New'" color="#000000">VIA</font> section of the LEF file. The members of the C++ class and C structures correspond to elements of the <font size="2" face="'Courier New'" color="#000000">LAYER</font> statement in the <font size="2" face="'Courier New'" color="#000000">VIA</font> section. </p>
      <p><a name="1039642">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">VIA</font> section, see <a href="../lefdefref/LEFSyntax.html#Via" target="external_window"><font color="#0000ff"><u>&#34;Via&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1038446">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1061515">class lefiViaLayer {<dd>int numRects();<dd>char* name();<dd>double xl(int index);<dd>double yl(int index);<dd>double xh(int index);<dd>double yh(int index);<dd>int numPolygons();<dd>struct lefiGeomPolygon* getPolygon(int index) const; <dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double </a><font size="2" face="'Courier New'" color="#000000"><em>xl</em></font>,<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double <font size="2" face="'Courier New'" color="#000000"><em>yl<dd></em></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double <font size="2" face="'Courier New'" color="#000000"><em>xh<dd></em></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double <font size="2" face="'Courier New'" color="#000000"><em>yn</em></font>);<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lefiGeometries* geom);<dd>int rectColorMask(int index); <dd>int polyColorMask(int index); };</font>
      </dl>
      <h3><a name="1038565">Via Examples</a></h3>
      <p><a name="1038566">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrViaCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiVia</font>.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038567">int viaCB (lefrCallbackType_e type,<dd>           lefiVia* viaInfo,<dd>           lefiUserData userData) {<dd></a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038568">    int i, j;<dd><dd>    &#47;&#47; Check if the type is correct<dd>    if (type != lefrViaCbkType) {<dd>        printf(&#34;Type is not lefrViaCbkType, terminate<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parsing.\n&#34;);<dd>        return 1;}<dd><dd>    printf(&#34;VIA %s &#34;, viaInfo&#45;&#62;lefiVia::name());<dd>    if (viaInfo&#45;&#62;hasDefault())<dd>        printf(&#34;DEFAULT\n&#34;);<dd>    else<dd>        printf(&#34;\n&#34;);<dd>    if (viaInfo&#45;&#62;hasTopOfStack())<dd>        printf(&#34;  TOPOFSTACKONLY\n&#34;);<dd>    if (viaInfo&#45;&#62;hasForeign()) {<dd>        printf(&#34;  FOREIGN %s &#34;, viaInfo&#45;&#62;foreign());<dd>        if (viaInfo&#45;&#62;hasForeignPnt()) {<dd>            printf(&#34;( %g %g ) &#34;, viaInfo&#45;&#62;foreignX(), <dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viaInfo&#45;&#62;foreignY());<dd>           if (viaInfo&#45;&#62;hasForeignOrient())<dd>               printf(&#34;%s &#34;, orientStr(viaInfo&#45;&#62;foreignOrient()));<dd>        }<dd>        printf(&#34;\n&#34;);<dd>    }<dd>    if (viaInfo&#45;&#62;hasProperties()) {<dd>        printf(&#34;  PROPERTY &#34;);<dd>        for (i = 0; i &#60; viaInfo&#45;&#62;numProperties(); i++) {<dd>            printf(&#34;%s &#34;, viaInfo&#45;&#62;propName(i));<dd>            if (viaInfo&#45;&#62;propIsNumber(i))<dd>                printf(&#34;%g &#34;, viaInfo&#45;&#62;propNumber(i));<dd>            if (viaInfo&#45;&#62;propIsString(i))<dd>                printf(&#34;%s &#34;, viaInfo&#45;&#62;propValue(i));<dd>        }<dd>        printf(&#34;\n&#34;);<dd>    }<dd>    if (viaInfo&#45;&#62;hasResistance())<dd>        printf(&#34;  RESISTANCE %g\n&#34;, viaInfo&#45;&#62;resistance());<dd>    if (viaInfo&#45;&#62;numLayers() &#62; 0) {<dd>        for (i = 0; i &#60; viaInfo&#45;&#62;numLayers(); i++) {<dd>            printf(&#34;  LAYER %s\n&#34;, viaInfo&#45;&#62;layerName(i));<dd>            for (j = 0; j &#60; viaInfo&#45;&#62;numRects(i); j++)<dd>                printf(&#34;    RECT ( %g %g ) ( %g %g )\n&#34;,<br>                       viaInfo&#45;&#62;xl(i, j), viaInfo&#45;&#62;yl(i, j),<br>                       viaInfo&#45;&#62;xh(i, j), viaInfo&#45;&#62;yh(i, j));<br>         }<br>     }<br>     printf(&#34;END %s\n&#34;, viaInfo&#45;&#62;name());<br>     return 0;}</a></font>
      </dl>
      <h2><a name="1038580">Via Rule Classes</a></h2>
      <p><a name="1038581">The LEF </a><font size="2" face="'Courier New'" color="#000000">VIARULE</font> routines include the following LEF classes:</p>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiViaRule" title="4" name="1055217"><font color="Blue"><u>lefiViaRule</u></font></a><a href="#lefiViaRule" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <div>
        <table border="0" cellspacing="0" cellpadding="3" summary="">
          <tr valign="baseline">
            <td width="31.999679999999998">
              <div>
                <nobr>
                  <font color="#000000"><img src="images/b_bullet.gif" alt="ParagraphBullet" border="0"></font>
                </nobr>
              </div>
            </td>
            <td><a href="#lefiViaRuleLayer" title="4" name="1055223"><font color="Blue"><u>lefiViaRuleLayer</u></font></a><a href="#lefiViaRuleLayer" title="4"> </a></td>
          </tr>
        </table>
      </div>
      <h3><a name="lefiViaRule"></a><a name="1055227">lefiViaRule</a></h3>
      <p><a name="1038560">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">VIARULE</font> and <font size="2" face="'Courier New'" color="#000000">VIARULE</font> <font size="2" face="'Courier New'" color="#000000">GENERATE</font> statements of the LEF file.</p>
      <p><a name="1039649">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">VIARULE</font> and <font size="2" face="'Courier New'" color="#000000">VIARULE</font> <font size="2" face="'Courier New'" color="#000000">GENERATE</font> statements, see <a href="../lefdefref/LEFSyntax.html#ViaRule" target="external_window"><font color="#0000ff"><u>&#34;Via Rule,&#34;</u></font></a>  and <a href="../lefdefref/LEFSyntax.html#ViaRuleGenerate" target="external_window"><font color="#0000ff"><u>&#34;Via Rule Generate&#34;</u></font></a> in the <font color="#000000"><em>LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1038468">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038469">class lefiViaRule {<dd>int hasGenerate() const;<dd>int hasDefault() const;<dd>char* name() const;</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1053164">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numLayers() const;<dd></a><font color="#0000ff"><u>lefiViaRuleLayer</u></font>* layer(int index);</font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1053166">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numVias() const;<dd>char* viaName(int index) const; </a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038473">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numProps() const;<dd>const char* propName(int index) const;<dd>const char* propValue(int index) const;<dd>double propNumber(int index) const;<dd>const char propType(int index) const;<dd>int propIsNumber(int index) const;<dd>int propISString(int index) const; };</a></font>
      </dl>
      <h3><a name="lefiViaRuleLayer"></a><a name="1038659">lefiViaRuleLayer</a></h3>
      <p><a name="1038660">Retrieves data from the </a><font size="2" face="'Courier New'" color="#000000">LAYER</font> statement within the <font size="2" face="'Courier New'" color="#000000">VIARULE</font> and <font size="2" face="'Courier New'" color="#000000">VIARULE</font> <font size="2" face="'Courier New'" color="#000000">GENERATE</font> statements of the LEF file. </p>
      <p><a name="1038666">For syntax information about the LEF </a><font size="2" face="'Courier New'" color="#000000">VIARULE</font> and <font size="2" face="'Courier New'" color="#000000">VIARULE</font> <font size="2" face="'Courier New'" color="#000000">GENERATE</font> statements, see <a href="../lefdefref/LEFSyntax.html#ViaRule" target="external_window"><font color="#0000ff"><u>&#34;Via Rule,&#34;</u></font></a>  and <a href="../lefdefref/LEFSyntax.html#ViaRuleGenerate" target="external_window"><font color="#0000ff"><u>&#34;Via Rule Generate&#34;</u></font></a> in the<font color="#000000"><em> LEF&#47;DEF Language Reference</em></font>.</p>
      <h4><a name="1038668">C++ Syntax</a></h4>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038669">class lefiViaRuleLayer {<dd>int hasDirection() const;<dd>int hasEnclosure() const;<dd>int hasWidth() const;<dd>int hasResistance() const;<dd>int hasOverhang() const;<dd>int hasMetalOverhang() const;<dd>int hasSpacing() const;<dd>int hasRect() const;</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038670">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char*  name() const;<dd>int isHorizontal() const;<dd>int isVertical() const;<dd>double enclosureOverhang1() const;<dd>double enclosureOverhang2() const;<dd>double widthMin() const;<dd>double widthMax() const;<dd>double overhang() const;<dd>double metalOverhang() const;<dd>double resistance() const;<dd>double spacingStepX() const;<dd>double spacingStepY() const;<dd>double xl() const; <dd>double yl() const;<dd>double xh() const;<dd>double yh() const; };</a></font>
      </dl>
      <h3><a name="1038719">Via Rule Examples</a></h3>
      <p><a name="1038720">The following example shows a callback routine with the type </a><font size="2" face="'Courier New'" color="#000000">lefrViaRuleCbkType</font>, and the class <font size="2" face="'Courier New'" color="#000000">lefiViaRule</font>. This example also shows how to retrieve data from the <font size="2" face="'Courier New'" color="#000000">lefiViaRuleLayer</font> class.</p>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1038721">int viaRuleCB (lefrCallbackType_e type,<dd>               lefiViaRule* viaRuleInfo,<dd>               lefiUserData userData) {<dd><dd>    int               numLayers, numVias, i;<dd>    lefiViaRuleLayer* vLayer;<dd><dd>    printf(&#34;VIARULE %s&#34;, viaRuleInfo&#45;&#62;name());<dd>    if (viaRuleInfo&#45;&#62;hasGenerate())<dd>        printf(&#34; GENERATE\n&#34;);<dd>    else<dd>        printf(&#34;\n&#34;);<dd><dd>    numLayers = viaRuleInfo&#45;&#62;numLayers();<dd>    &nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; If numLayers == 2, it is VIARULE without GENERATE and has<dd> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; via name. If numLayers == 3, it is VIARULE with GENERATE, and<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#47;&#47; the 3rd layer is cut.<dd>    for (i = 0; i &#60; numLayers; i++) {<dd>        vLayer = viaRuleInfo&#45;&#62;layer(i);<dd>        printf(&#34;  LAYER %s\n&#34;, vLayer&#45;&#62;name());<dd>        if (vLayer&#45;&#62;hasDirection()) {<dd>            if (vLayer&#45;&#62;isHorizontal())<dd>                printf(&#34;    DIRECTION HORIZONTAL\n&#34;);<dd>            if (vLayer&#45;&#62;isVertical())<dd>                printf(&#34;    DIRECTION VERTICAL\n&#34;);<dd>        }<dd>        if (vLayer&#45;&#62;hasWidth())<dd>            printf(&#34;    WIDTH %g TO %g\n&#34;, vLayer&#45;&#62;widthMin(),<dd>                   vLayer&#45;&#62;widthMax());<dd>        if (vLayer&#45;&#62;hasResistance())<dd>            printf(&#34;    RESISTANCE %g\n&#34;, vLayer&#45;&#62;resistance());<dd>        if (vLayer&#45;&#62;hasOverhang())<dd>            printf(&#34;    OVERHANG %g\n&#34;, vLayer&#45;&#62;overhang());<dd>        if (vLayer&#45;&#62;hasMetalOverhang())<dd>            printf(&#34;    METALOVERHANG %g\n&#34;, vLayer&#45;<dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#62;metalOverhang());<dd>        if (vLayer&#45;&#62;hasSpacing())<dd>            printf(&#34;    SPACING %g BY %g\n&#34;, vLayer&#45;&#62;spacingStepX(),<dd>                   vLayer&#45;&#62;spacingStepY());<dd>        if (vLayer&#45;&#62;hasRect())<br>            printf(&#34;    RECT ( %g %g ) ( %g %g )\n&#34;, vLayer&#45;&#62;xl(),<br> 					vLayer&#45;&#62;yl(), vLayer&#45;&#62;xh(), vLayer&#45;&#62;yh()); }<br><br>    if (numLayers == 2) {    &#47;&#47; should have vianames<br>        numVias = viaRuleInfo&#45;&#62;numVias();<br>        if (numVias == 0)<br>            printf(&#34;Should have via names in VIARULE.\n&#34;);<br>        else {<br>            for (i = 0; i &#60; numVias; i++)<br>                printf(&#34;  VIA %s\n&#34;, viaRuleInfo&#45;&#62;viaName(i));<br>        }<br>    }<br>    printf(&#34;END %s\n&#34;, viaRuleInfo&#45;&#62;name());<br>    return 0;}</a></font>
      </dl>
      <dl>
        <font size="2" face="'Courier New'" color="#000000"><a name="1058840">&nbsp;</a></font>
      </dl>
    </div>
    <br>
    <a href="#pagetop">Return to top of page</a>
    <hr>
    <hr align="left">
    <div style="text-align: left;">
      <!-- Begin Buttons -->
      <table width="650" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td height="20" width="59">
<a href="javascript:openLibrary()"><img src="../support/nav2_library.gif" border="0" alt="View Library" height="20" width="59"></a>
                    </td>
<td height="20" width="73">
<a href="lefapiTOC.html"><img src="../support/nav2_toc.gif" alt="Table of Contents" border="0"></a>
</td>

<td height="20" width="46">
<img src="../support/nav2_index_b.gif" border="0">
</td>
          <td>
            <a href="ch3LEFcallback.html"><img src="images/nav2_previous.gif" alt="Previous" border="0"></a>
          </td>
          <td>
            <a href="ch5LEFwritercallback.html"><img src="images/nav_next.gif" alt="Next" border="0"></a>
          </td>
          <td>
            <a>
<a href="lefapi.pdf"><img src="../support/nav2_print.gif" border="0" alt="Open PDF to print book" height="20" width="114"></a>
            </a>
          </td>
          <td height="20" width="61">
<img src="../support/nav2_black.gif" border="0"  height="20" width="76">
          </td>
          <td height="20" width="76">
<a href="/feedback.htm"><img src="../support/nav2_feedback.gif" border="0" alt="Email Comments" height="20" width="76"></a>
          </td>
          <td height="20" width="43">
<a href="../cdsuser/help.html"><img src="../support/nav2_help.gif" border="0" alt="Help Using Documentation" height="20" width="43"></a>
          </td>
          <td height="20" width="37">
<a href="/exitsearch.htm"><img src="../support/nav2_exit.gif" border="0" alt="Shut Down Cadence Documentation Server" height="20" width="37"></a>
          </td>
        </tr>
      </table>
      <!-- End Buttons -->
    </div>
    <br>
    <font size="-1" >
For support, see <a href="http://support.cadence.com" target="_blank">Cadence Online Support</a> service.</font>
    <br>
    <br>
    <font size="-1" >
<font size="-1"><i>Copyright &#169; 2016, <a href ="http://www.cadence.com">Cadence Design Systems, Inc.</a></i></font>
    </font>
    <br>
    <font size="-1" >
All rights reserved.</font>
    <br>
    <br>
  </body>
</html>
